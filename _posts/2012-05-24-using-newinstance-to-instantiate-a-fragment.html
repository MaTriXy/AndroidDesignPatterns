---
layout: post
title: Using "newInstance()" to Instantiate a Fragment
date: 2012-05-24
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>I recently came across an interesting question on StackOverflow regarding Fragment instantiation:</p> <blockquote class="tr_bq">What is the difference between <code>new MyFragment()</code> and <code>MyFragment.newInstance()</code>? Should I prefer one over the other?</blockquote> <p>Good question. The answer, as the title of this blog suggests, is a matter of proper design.</p> <p>Here, the <code>newInstance()</code> method is what we call a "static factory method", a simple pattern that is often used as a way to instantiate an object without directly calling the object's default constructor. For example, it is often used to implement a Singleton design pattern:</p> <p><pre class="brush: java"><br />public static class Singleton {<br /><br />    private static final Singleton instance = null;<br />    <br />    /** <br />     * Make the class private to prevent direct instantiation. This <br />     * forces clients to call newInstance(), which will ensure the<br />     * class' Singleton property.<br />     */<br />    private Singleton() { }<br />   <br />    /**<br />     * If instance is null, then instantiate the object by calling<br />     * the default constructor (this is OK since we are calling<br />     * it from within the class). This method should be marked<br />     * "synchronized" if you plan on calling it from multiple threads!<br />     */ <br />    public static Singleton getInstance() {<br />        if (instance == null) {<br />            instance = new Singleton();<br />        }<br />        return instance;<br />    }<br />}<br /></pre></p> <a name='more'></a> <p>The programmer forces the client to call <code>newInstance()</code> to retrieve an instance of the class. This is important because simply providing a default constructor would allow the client access to multiple instances of the class (as this goes against the singleton property).</p> <p>The same general idea is often applied to fragments. Providing a static factory method for your fragments is good practice when you want to add initialization arguments to the newly instantiated object. For example, consider the following code:</p> <p><pre class="brush: java"><br />public class MyFragment extends Fragment {<br /><br />  /**<br />   * Static factory method that takes an int parameter,<br />   * initializes the fragment's arguments, and returns the<br />   * new fragment to the client.<br />   */<br />  public static MyFragment newInstance(int index) {<br />    MyFragment f = new MyFragment();<br />    Bundle args = new Bundle();<br />    args.putInt("index", index);<br />    f.setArguments(args);<br />    return f;<br />  }<br />}<br /></pre></p> <p>Rather than having the client call the default constructor and manually set the fragment's arguments themselves, we provide a static factory method that does this for them. This is preferred over the default constructor for two reasons. One, it's convenient for the client, and two, it enforces well-defined behavior. By providing a static factory method, we protect ourselves from bugs down the line--we no longer need to worry about accidentally forgetting to initialize the fragment's arguments or incorrectly doing so.</p> <p>Overall, while the difference between the two is mostly just a matter of design, this difference is really important because it provides another level of abstraction and makes code a lot easier to understand.</p> <p>Leave a comment if this helped... it'll motivate me to write more of these blog posts in the future! :)</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Sure, and I think this is mostly the reason why so many Android tutorials on the developers site uses the newInstance() approach (because it makes use of the well-known static factory method and makes the code more manageable and easily understood). Using Fragment#instantiate() as recommended above is perhaps a little less clear. <br /><br />Hopefully this answered your question... I wasn&#39;t 100% certain about what you were asking. :)</div>
</div>
<div class='comment'>
<div class='author'>Charles Thomas</div>
<div class='content'>
Would an acceptable answer to the comment about using a default constructor and setters as you did in the example, be that by maintaining a well-known pattern makes your code more easily understood?<br />I am a newbie to android/java -- having come from 20 years of C/C++ -- patterns are a life-saver.<br /><br />Another thought along these same lines -- in the land of C++ (and I assume Java) a factory doesn&#39;t only have to create an instance of a specific class.  It can also instantiate a class that inherits the base class (or extends in Java).  <br /><br />So in the newInstance() function above .. (and in something I am working on now) the parameters to newInstance help determine what fragment type is created.  If I have a base class of &quot;CharleyFragment&quot; that are extended to create   &quot;CharleyFoodFragment&quot;, &quot;CharleyFuelFragment&quot;, etc.  then I can call into the factory function newInstance(String resource_type)... and let it create the appropriate fragment.<br /><br />And with ComponentName(String package_id, String class_name) I can get even more creative....<br /><br />?<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I still like this approach for one argument or few, I use inner Builder pattern if large number of arguments such as AlertDialog.Builder or Notification.Builder.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
You can implement parcelable or serializable to your object, then use args.putParcelable or args.putSerializable.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
One issue I&#39;ve been having is that I wish to pass an object through to the Bundle, this cannot be done with this without addintional code :/<br /><br />Example:<br />  public static MyFragment newInstance(Object index) {<br />    MyFragment f = new MyFragment();<br />    Bundle args = new Bundle();<br />    // args.putObject(obj); does not exist!<br />    f.setArguments(args);<br />    return f;<br />  }</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Great piece of work (code too), now i have a better idea about the instantiating of fragment, and how useful are design patterns </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yes, you are correct. This is an old post and I should probably update it and/or eliminate the singleton reference... :/</div>
</div>
<div class='comment'>
<div class='author'>MNT</div>
<div class='content'>
Hello, the anonymous poster is right. I am facing exactly that problem, that fragments are no singletons at all. The get re-instantiated by the fragment manager on a screen rotate.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
+1, that&#39;d good advice. I guess the only difference would be that you&#39;d need to cast the result from Fragment, but I think I will consider using this in the future. :)</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
No need to use default constructor and setters as you wrote. You can do it using default constructor, and passing arguments as Bundle in one go<br /><br />Fragment.instantiate(context, MyFragment.class.getName(), arguments);<br /><br />then you just need to access those arguments inside Fragment by getArguments() and TADA!</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Ditto. Would love someone to answer this as I don&#39;t get it either. Why have a static function instead of a non-default constructor? They both require an explicit call.<br />Also, if you make the default MyFragment constructor private, how is the android system going to instantiate that Fragment on orientation or some other change?<br />In Eclipse ADT, there&#39;s a lint rule that doesn&#39;t even allow you to make a private default constructor for a Fragment subclass.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
This is the part I can&#39;t get my head around. What is the difference between newInstance(int id) and MyFragment(int id). <br /><br />If you&#39;re going to make the default constructor private anyway then you may as well just have the one constructor passing in the variables that need to be initialised (is the default used by anyone). This will actually make your code more understandable then having a factory method that simply returns an instance of itself.<br /><br />    public MyFragment (int index) {<br />        super();<br />        Bundle args = new Bundle();<br />        args.putInt(&quot;index&quot;, index);<br />        setArguments(args);<br />    }</div>
</div>
<div class='comment'>
<div class='author'>top phone 4 cases</div>
<div class='content'>
What if I add 2 constructors? Both public, one with zero arguments and the one with the arguments I want... Wouldn&#39;t that work too?</div>
</div>
<div class='comment'>
<div class='author'>Виталий Филатов</div>
<div class='content'>
thanks for this artical! Very intersting!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Usually you instantiate Fragments only once (i.e. in an Activity lifecycle method which is only called once, like onCreate for example), so I guess that is usually enough to guarantee that the Fragment will only be instantiated once. Also, what if an application had two panes and each pane wanted to display an instance of the same fragment? It might seem weird, but there is nothing in the framework which says this isn&#39;t allowed! :)<br /><br />That said, you are right that there is an inconsistency here... I think that is my fault, because I guess comparing fragment instantiation with the singleton pattern isn&#39;t all that correct. The point I was trying to get across was that both use a static factory method which you use for instantiation instead of the class&#39; default constructor.</div>
</div>
<div class='comment'>
<div class='author'>Michael Mossman</div>
<div class='content'>
Just on other thought.<br />Could you please help us even further by showing how this instantiation will appear in the parent Activity. The official example does this on the following lines :-<br /><br />    PickListFragment picklistFragment = new PickListFragment();<br />             picklistFragment.setArguments(getIntent().getExtras());<br />             getSupportFragmentManager().beginTransaction()<br />                     .add(R.id.pickrightpane, picklistFragment).commit();<br />         }<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Bohsen</div>
<div class='content'>
Why are you not in the Fragment-example in the newInstance-method checking for a reference to your fragment like in the singleton-example? Doesn&#39;t it matter if multiple instances of your fragment is created?</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Make the default constructor private is not so good. When instrumenation (screen rotation) is used, an exception will be raised.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
If you are instantiating Fragments on anything other than the main UI thread then you probably have far greater problems than the possible occurrence of a race condition when calling getInstance from multiple threads. The extra cost of synchronization would be silly, IMO... just make sure you only create Fragments on the UI thread and you&#39;re good to go :)<br /><br />That said, I probably should have been more clear in the first bit of sample code explaining the Singleton pattern... I&#39;ve updated the code to point out that it is not thread safe. I&#39;ve also changed the name to &quot;getInstance&quot; as it doesn&#39;t always create a new instance, like you said. Thanks for pointing that out!</div>
</div>
<div class='comment'>
<div class='author'>Joseph Earl</div>
<div class='content'>
Your solution is not thread safe. You should synchronize access to the newInstance method in some manner.<br />Furthermore it is typical to call the singleton accessor &quot;getInstance&quot; since it does not always create a new  instance.</div>
</div>
<div class='comment'>
<div class='author'>David</div>
<div class='content'>
At first I was wondering how useful that would be. And then I read the first two of the last three paragraphs...</div>
</div>
</div>
