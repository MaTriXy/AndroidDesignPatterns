---           
layout: post
title: Using "newInstance()" to Instantiate a Fragment
date: 2013-08-23 02:12:02 UTC
updated: 2013-08-23 02:12:02 UTC
comments: false
categories: 
---
 
<p>I recently came across an interesting question on StackOverflow regarding Fragment instantiation:</p> <blockquote class="tr_bq">What is the difference between <code>new MyFragment()</code> and <code>MyFragment.newInstance()</code>? Should I prefer one over the other?</blockquote> <p>Good question. The answer, as the title of this blog suggests, is a matter of proper design.</p> <p>Here, the <code>newInstance()</code> method is what we call a "static factory method", a simple pattern that is often used as a way to instantiate an object without directly calling the object's default constructor. For example, it is often used to implement a Singleton design pattern:</p> <p><pre class="brush: java"><br />public static class Singleton {<br /><br />    private static final Singleton instance = null;<br />    <br />    /** <br />     * Make the class private to prevent direct instantiation. This <br />     * forces clients to call newInstance(), which will ensure the<br />     * class' Singleton property.<br />     */<br />    private Singleton() { }<br />   <br />    /**<br />     * If instance is null, then instantiate the object by calling<br />     * the default constructor (this is OK since we are calling<br />     * it from within the class). This method should be marked<br />     * "synchronized" if you plan on calling it from multiple threads!<br />     */ <br />    public static Singleton getInstance() {<br />        if (instance == null) {<br />            instance = new Singleton();<br />        }<br />        return instance;<br />    }<br />}<br /></pre></p> <a name='more'></a> <p>The programmer forces the client to call <code>newInstance()</code> to retrieve an instance of the class. This is important because simply providing a default constructor would allow the client access to multiple instances of the class (as this goes against the singleton property).</p> <p>The same general idea is often applied to fragments. Providing a static factory method for your fragments is good practice when you want to add initialization arguments to the newly instantiated object. For example, consider the following code:</p> <p><pre class="brush: java"><br />public class MyFragment extends Fragment {<br /><br />  /**<br />   * Static factory method that takes an int parameter,<br />   * initializes the fragment's arguments, and returns the<br />   * new fragment to the client.<br />   */<br />  public static MyFragment newInstance(int index) {<br />    MyFragment f = new MyFragment();<br />    Bundle args = new Bundle();<br />    args.putInt("index", index);<br />    f.setArguments(args);<br />    return f;<br />  }<br />}<br /></pre></p> <p>Rather than having the client call the default constructor and manually set the fragment's arguments themselves, we provide a static factory method that does this for them. This is preferred over the default constructor for two reasons. One, it's convenient for the client, and two, it enforces well-defined behavior. By providing a static factory method, we protect ourselves from bugs down the line--we no longer need to worry about accidentally forgetting to initialize the fragment's arguments or incorrectly doing so.</p> <p>Overall, while the difference between the two is mostly just a matter of design, this difference is really important because it provides another level of abstraction and makes code a lot easier to understand.</p> <p>Leave a comment if this helped... it'll motivate me to write more of these blog posts in the future! :)</p><img src="http://feeds.feedburner.com/~r/androiddesignpatterns/~4/EWn_2d6a1P8" height="1" width="1"/>