---
layout: post
title: Activitys, Threads, & Memory Leaks
date: 2013-04-15
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>A common difficulty in Android programming is coordinating long-running tasks over the Activity lifecycle and avoiding the subtle memory leaks which might result. Consider the Activity code below, which starts and loops a new thread upon its creation:</p> <p><pre class="brush:java">/**<br /> * Example illustrating how threads persist across configuration<br /> * changes (which cause the underlying Activity instance to be<br /> * destroyed). The Activity context also leaks because the thread<br /> * is instantiated as an anonymous class, which holds an implicit<br /> * reference to the outer Activity instance, therefore preventing<br /> * it from being garbage collected.<br /> */<br />public class MainActivity extends Activity {<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br />    exampleOne();<br />  }<br /><br />  private void exampleOne() {<br />    new Thread() {<br />      @Override<br />      public void run() {<br />        while (true) {<br />          SystemClock.sleep(1000);<br />        }<br />      }<br />    }.start();<br />  }<br />}</pre></p> <p><b>Note:</b> the source code in this blog post is available on <a href="https://github.com/alexjlockwood/leaky-threads">GitHub</a>.</p> <p>When a configuration change occurs, causing the entire Activity to be destroyed and re-created, it is easy to assume that Android will clean up after us and reclaim the memory associated with the Activity and its running thread. However, this is not the case. Both will leak never to be reclaimed, and the result will likely be a significant reduction in performance.</p> <a name='more'></a> <h4>How to Leak an Activity</h4> <p>The first memory leak should be immediately obvious if you read my <a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">previous post</a> on Handlers and inner classes. In Java, non-static anonymous classes hold an implicit reference to their enclosing class. If you're not careful, storing this reference can result in the Activity being retained when it would otherwise be eligible for garbage collection. Activity objects hold a reference to their entire view hierarchy and all its resources, so if you leak one, you leak a lot of memory.</p> <p>The problem is only exacerbated by configuration changes, which signal the destruction and re-creation of the entire underlying Activity. For example, after ten orientation changes running the code above, we can see (using <a href="http://www.eclipse.org/mat/">Eclipse Memory Analyzer</a>) that each Activity object is in fact retained in memory as a result of these implicit references:</p> <table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: center; margin-left: 0em; text-align: left;">  <tbody>    <tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-EKohlXPS6dk/UWwwQaH8AEI/AAAAAAAAHJI/EIFY4B3yg6w/s1600/chart134.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="175" src="http://4.bp.blogspot.com/-EKohlXPS6dk/UWwwQaH8AEI/AAAAAAAAHJI/EIFY4B3yg6w/s400/chart134.png" width="400" /></a>    </td></tr>    <tr><td class="tr-caption" style="text-align: center;">Figure 1. Activity instances retained in memory after ten orientation changes.     </td></tr>  </tbody></table> <p>After each configuration change, the Android system creates a new Activity and leaves the old one behind to be garbage collected. However, the thread holds an implicit reference to the old Activity and prevents it from ever being reclaimed. As a result, each new Activity is leaked and all resources associated with them are never able to be reclaimed.</p> <p>The fix is easy once we've identified the source of the problem: declare the thread as a private static inner class as shown below.</p> <p><pre class="brush:java">/**<br /> * This example avoids leaking an Activity context by declaring the <br /> * thread as a private static inner class, but the threads still <br /> * continue to run even across configuration changes. The DVM has a<br /> * reference to all running threads and whether or not these threads<br /> * are garbaged collected has nothing to do with the Activity lifecycle.<br /> * Active threads will continue to run until the kernel destroys your <br /> * application's process.<br /> */<br />public class MainActivity extends Activity {<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br />    exampleTwo();<br />  }<br /><br />  private void exampleTwo() {<br />    new MyThread().start();<br />  }<br /><br />  private static class MyThread extends Thread {<br />    @Override<br />    public void run() {<br />      while (true) {<br />        SystemClock.sleep(1000);<br />      }<br />    }<br />  }<br />}</pre></p> <p>The new thread no longer holds an implicit reference to the Activity, and the Activity will be eligible for garbage collection after the configuration change.</p> <h4>How to Leak a Thread</h4> <p>The second issue is that for each new Activity that is created, a thread is leaked and never able to be reclaimed. Threads in Java are GC roots; that is, the Dalvik Virtual Machine (DVM) keeps hard references to all active threads in the runtime system, and as a result, threads that are left running will never be eligible for garbage collection. For this reason, you must remember to implement cancellation policies for your background threads! One example of how this might be done is shown below:</p> <p><pre class="brush:java">/**<br /> * Same as example two, except for this time we have implemented a<br /> * cancellation policy for our thread, ensuring that it is never <br /> * leaked! onDestroy() is usually a good place to close your active <br /> * threads before exiting the Activity.<br /> */<br />public class MainActivity extends Activity {<br />  private MyThread mThread;<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br />    exampleThree();<br />  }<br /><br />  private void exampleThree() {<br />    mThread = new MyThread();<br />    mThread.start();<br />  }<br /><br />  /**<br />   * Static inner classes don't hold implicit references to their<br />   * enclosing class, so the Activity instance won't be leaked across<br />   * configuration changes.<br />   */<br />  private static class MyThread extends Thread {<br />    private boolean mRunning = false;<br /><br />    @Override<br />    public void run() {<br />      mRunning = true;<br />      while (mRunning) {<br />        SystemClock.sleep(1000);<br />      }<br />    }<br /><br />    public void close() {<br />      mRunning = false;<br />    }<br />  }<br /><br />  @Override<br />  protected void onDestroy() {<br />    super.onDestroy();<br />    mThread.close();<br />  }<br />}</pre></p> <p>In the code above, closing the thread in <code>onDestroy()</code> ensures that you never accidentally leak the thread. If you want to persist the same thread across configuration changes (as opposed to closing and re-creating a new thread each time), consider using a retained, UI-less worker fragment to perform the long-running task. Check out my blog post, titled <a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a>, for an example explaining how this can be done. There is also a comprehensive example available in the <a href="https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/app/FragmentRetainInstance.java">API demos</a> which illustrates the concept.</p> <h4>Conclusion</h4> <p>In Android, coordinating long-running tasks over the Activity lifecycle can be difficult and memory leaks can result if you aren't careful. Here are some general tips to consider when dealing with coordinating your long-running background tasks with the Activity lifecycle:</p> <ul> <li><p><b>Favor static inner classes over nonstatic.</b> Each instance of a nonstatic inner class will have an extraneous reference to its outer Activity instance. Storing this reference can result in the Activity being retained when it would otherwise be eligible for garbage collection. If your static inner class requires a reference to the underlying Activity in order to function properly, make sure you wrap the object in a <code>WeakReference</code> to ensure that you don't accidentally leak the Activity.</p></li> <li><p><b>Don't assume that Java will ever clean up your running threads for you.</b> In the example above, it is easy to assume that when the user exits the Activity and the Activity instance is finalized for garbage collection, any running threads associated with that Activity will be reclaimed as well. <i>This is never the case.</i> Java threads will persist until either they are explicitly closed or the entire process is killed by the Android system. As a result, it is extremely important that you remember to implement cancellation policies for your background threads, and to take appropriate action when Activity lifecycle events occur.</p></li> <li><p><b>Consider whether or not you should use a Thread.</b> The Android application framework provides many classes designed to make background threading easier for developers. For example, consider using a Loader instead of a thread for performing short-lived asynchronous background queries in conjunction with the Activity lifecycle. Likewise, if your the background thread is not tied to any specific Activity, consider using a Service and report the results back to the UI using a <code>BroadcastReceiver</code>. Lastly, remember that everything discussed regarding threads in this blog post also applies to <code>AsyncTask</code>s (since the <code>AsyncTask</code> class uses an ExecutorService to execute its tasks). However, given that <code>AsyncTask</code>s should only be used for short-lived operations ("a few seconds at most", as per the <a href="http://developer.android.com/reference/android/os/AsyncTask.html">documentation</a>), leaking an Activity or a thread by these means should never be an issue.</p></li> </ul> <p>The source code for this blog post is available on <a href="https://github.com/alexjlockwood/leaky-threads">GitHub</a>. A standalone application (which mirrors the source code exactly) is also available for download on <a href="https://play.google.com/store/apps/details?id=com.adp.leaky.threads">Google Play</a>.</p> <p><a href="https://play.google.com/store/apps/details?id=com.adp.leaky.threads" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-N40gsQs2Ytg/UXycCupURtI/AAAAAAAAHKE/HNLW-xEGGrc/s320/Screenshot_2013-04-27-16-22-17.png" /></a></p> <p>As always, leave a comment if you have any questions and don't forget to +1 this blog in the top right corner!</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
That&#39;s not necessary. Leaking an activity means that one of your objects is holding a reference to the activity for longer than it should have held it, thus preventing the garbage collector from reclaiming it. In this case, the anonymous runnable instance we have created here will be scheduled to be executed almost immediately on the main UI thread... in other words, the runnable will hold a reference to the activity for about 10-15ms before being executed by the main UI thread, after which the runnable will be reclaimed by the garbage collector.<br /><br />p.s. This is why my article about <a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html?showComment=1387475947875#c5406161336938634644" rel="nofollow">Handlers and Inner Classes</a> gives an example using Handler#postDelayed(). If the message wasn&#39;t &quot;delayed&quot;, then there would be no problem since the reference won&#39;t persist for more than a few milliseconds.</div>
</div>
<div class='comment'>
<div class='author'>Rahul Sapra</div>
<div class='content'>
Hi Alex, as per your reply for Dmytro Danylyk query &#39;updating ui from thread&#39;<br /><br />That would cause a race condition. You can&#39;t modify the activity directly from a background thread... you could do something like this though:<br /><br />activity.runOnUiThread(new Runnable() {<br />public void run() {<br />activity.uiMethod();<br />}<br />});    <br /><br />I think new Runnable should me made static class by extending for safer side. As activity is already WeakReference here but to be on safer side.. Correct me if i am wrong.  And many thanks to your I have read your many articles your have done a grt job. Many thanks to u again. Hoping article on &quot;when to use AsyncTask vs Service, vs DownloadManager, vs Loader and etc.&quot; from you. Thanks. </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Nope. Anonymous classes hold an implicit reference to their enclosing class, so this could potentially cause a memory leak (since the thread won&#39;t be GC&#39;d until it has terminated). Same thing would happen if you instantiated an anonymous AsyncTask instance and executed it.</div>
</div>
<div class='comment'>
<div class='author'>Henry Notengo Uno</div>
<div class='content'>
Thanks for your tips!!<br />I have a question, can i write something like:<br /><br />static class mThread extends Thread{<br /> @Override<br />        public void run() {}<br />}<br /><br /><br />...<br />new mThread(){<br /> @Override<br />        public void run() {<br />  ... Something<br /> }<br />}<br /><br />Same with AsyncTask. I&#39;m too new with Java hehe<br /><br />Thank you for any advice.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I think this is correct... have you looked at the contents of res/menu-v11/activity_main.xml? The Activity#recreate() method was added in API 11 so it&#39;s not included as a menu item by default (only for API 11 and above).</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hi Alex<br /><br />I think the version of activity_main.xml in GitHub is out of sync, it only declares 1 menu item &quot;menu_kill_process&quot;, where the activity makes references to &quot;menu_trigger_config_change&quot; also.<br /><br />Mike</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yup, that&#39;s why you need to stop the thread.</div>
</div>
<div class='comment'>
<div class='author'>Raaja</div>
<div class='content'>
To control memory leak we are creating a static inner class and also stopping the thread on onDestroy(). So i think by stopping the thread we are doubly sure that the thread won&#39;t leak when configuration change , even if it had an activity reference by all  means. is it wright Alex?</div>
</div>
<div class='comment'>
<div class='author'>Peace Manav</div>
<div class='content'>
Thanks Alex, you are making us better programmer :)</div>
</div>
<div class='comment'>
<div class='author'>tushar pandey</div>
<div class='content'>
ha-ha , form now ... i will also take care of it .</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hi, thanks ... heres the link<br /><br />http://stackoverflow.com/questions/17272474/memory-leak-despite-using-weakreference</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Impossible to tell without seeing the code. Post your code on StackOverflow and provide me a link to the post.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Good article. I made my non-static inner class to static and the leak was reduced but not eliminated. Despite making weakreference of almost every object a cannot eliminate the leak. Why?<br /><br /><br />The class is extending asynctask and taking care of scalingdown bitmaps and load those to a scrollview. Have read on several forums that weakreference is a solution to memoryleaks - and at the same time avoiding static inner classes.  </div>
</div>
<div class='comment'>
<div class='author'>Dmytro Danylyk</div>
<div class='content'>
Yes, the question is<br />1. Thread is doing long operation and then want to update UI<br />2. User opens and closes activity, thread is still in background but activity is destroyed<br />3. Since we are holding link to activity as WeakRef, activity is not leaked, right?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
That would cause a race condition. You can&#39;t modify the activity directly from a background thread... you could do something like this though:<br /><br />activity.runOnUiThread(new Runnable() {<br />public void run() {<br />activity.uiMethod();<br />}<br />});</div>
</div>
<div class='comment'>
<div class='author'>Dmytro Danylyk</div>
<div class='content'>
If you need to update UI from Thread, you need link to your activity. What about following code?<br /><br /> static class MyThread extends Thread {<br /><br /> WeakReference activityWeakReference;<br /> public MyThread(MyActivity activity) {<br />  activityWeakReference = new WeakReference(activity);<br /> }<br /><br /> @Override<br /> public void run() {<br />  MyActivity activity = activityWeakReference.get();<br />  if(activity != null) {<br />   activity.uiMethod();<br />  }<br /> }<br />}</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Did you read the StackOverflow answer in the link you provided? The reason for that behavior is due to a bug in DDMS debugging mode. If a thread is not run or has been stopped then it will not be leaked.</div>
</div>
<div class='comment'>
<div class='author'>TheDimasig</div>
<div class='content'>
You are not quite right. As you wrote in your previous post, new Thread can create a memory leak, because it can hold explicit reference to Activity. But if the Thread is done, it will be garbage collected by GC.<br /><br />If your assumption were true, then all of the applications in Android having more than one thread, sooner or later, would lead to OutOfMemoryError. But this is not happening.<br /><br />The answer to your question can be found on stackoverflow: http://stackoverflow.com/a/12813403/571914<br /><br />But with one addition. If the Thread was created (new called), but did not run (start not called), potentialy it will create memory leak because when you creating a new Thread, it registered in thread group and holds a reference to all what it has.<br /><br />Thus summing up again all the above, the Threads are collected by GC. But you should be carefull when creating them, and need to create just before use</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yup, I plan on doing that at some point. :)</div>
</div>
<div class='comment'>
<div class='author'>Ehsan Barekati</div>
<div class='content'>
Very helpful! I would appreciate a separate post on when to use AsyncTask vs Service, vs DownloadManager, vs Loader and etc.</div>
</div>
<div class='comment'>
<div class='author'>Jan1337z</div>
<div class='content'>
Thanks mate! Good post.</div>
</div>
<div class='comment'>
<div class='author'>Chris Margonis</div>
<div class='content'>
Very nice post. I was actually leaking my activities all the time.<br />Time to correct it without telling anyone!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
The difference between the two is very subtle and at times confusing, I agree. <br /><br />When it comes to picking between the two, I think the best solution is to just declare the class in a separate file. Sure, it&#39;s cumbersome, but then again so is almost everything about Java compared to most modern programming languages... and it is probably the safest way to avoid memory leaks because it makes it very obvious that there are no extraneous, hidden references pointing to objects which should otherwise be eligible for garbage collection.</div>
</div>
<div class='comment'>
<div class='author'>Kiran Rao</div>
<div class='content'>
Great article again! One thing I always trip over: There is a difference between static inner class and static variables of inner classes. I&#39;ve so often resisted creating a static inner AsyncTask because I wrongly assumed that it&#39;d restrict it to only one instance across all instances of my Activity.<br /><br />Maybe you should consider discussing this in your next post :-)</div>
</div>
</div>
