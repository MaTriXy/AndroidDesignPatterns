---
layout: post
title: SQLite, ContentProviders, and Thread Safety
date: 2012-10-11
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>A common source of confusion when implementing ContentProviders is that of thread-safety. We all know that any potentially expensive query should be asynchronous so as not to block the UI thread, but when, if ever, is it OK to make calls to the ContentProvider from multiple threads?</p> <h4>Threads and ContentProviders</h4> <p>The <a href="http://developer.android.com/reference/android/content/ContentProvider.html">documentation</a> on ContentProviders warns that its methods may be called from multiple threads and therefore must be thread-safe:</p> <p><blockquote>Data access methods (such as <span style="font-family: 'Courier New', Courier, monospace;">insert(Uri, ContentValues)</span> and <span style="font-family: 'Courier New', Courier, monospace;">update(Uri, ContentValues, String, String[]))</span> may be called from many threads at once, and must be thread-safe. </blockquote></p> <p>In other words, Android <b>does not</b> synchronize access to the ContentProvider for you. If two calls to the same method are made simultaneously from separate threads, neither call will wait for the other. Requiring the client to deal with concurrency themselves makes sense from a framework developer's point of view. The abstract ContentProvider class cannot assume that its subclasses will require synchronization, as doing so would be horribly inefficient.</p> <h4>Ensuring Thread Safety</h4> <p>So now that we know that the ContentProvider is not thread safe, what do we need to do in order to eliminate potential race conditions? Just make every method <span style="font-family: 'Courier New', Courier, monospace;">synchronized</span>, right?</p> <a name='more'></a> <p>Well... no, not necessarily. Consider a ContentProvider that uses a <span style="font-family: 'Courier New', Courier, monospace;">SQLiteDatabase</span> as its backing data source. As per the <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#setLockingEnabled(boolean)">documentation</a>, access to the <span style="font-family: 'Courier New', Courier, monospace;">SQLiteDatabase</span> is synchronized by default, thus guaranteeing that no two threads will ever touch it at the same time. In this case, synchronizing each of the ContentProvider's methods is both unnecessary and costly. Remember that a ContentProvider serves as a wrapper around the underlying data source; whether or not you must take extra measures to ensure thread safety often depends on the data source itself.</p> <h4>Conclusion</h4> <p>Although the ContentProvider lacks in thread-safety, often times you will find that no further action is required on your part with respect to preventing potential race conditions. The canonical example is when your ContentProvider is backed by a <span style="font-family: 'Courier New', Courier, monospace;">SQLiteDatabase</span>; when two threads attempt to write to the database at the same time, the <span style="font-family: 'Courier New', Courier, monospace;">SQLiteDatabase</span> will lock itself down, ensuring that one will wait until the other has completed. Each thread will be given mutually exclusive access to the data source, ensuring the thread safety is met.</p> <p>This has been a rather short post, so don't hesitate to leave a comment if you have any clarifying questions. Don't forget to +1 this post below if you found it helpful! :)</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>张晓文</div>
<div class='content'>
thanks!</div>
</div>
<div class='comment'>
<div class='author'>MUnique</div>
<div class='content'>
In my app, I have implemented multiple content providers for a single db, one per table, as there are a lot of tables and having the logic of all of them in a single content provider is going to be quite messy.<br /><br />So there is an abstract AbsShopContentProvider that has a SQLiteOpenHelper member variable. This abstract content provider is then extended by multiple content providers like Table1Provider, Table2Provider,...<br /><br /><br />So now I have one instance of my SQLiteOpenHelper per Content Provider. Will this create any issues regarding thread safety?<br /><br />Is it a good idea to make this SQLiteOpenhelper variable &quot;static&quot; in my abstract Content Provider?<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Those exceptions don&#39;t sound like they are related to threads/concurrency. My guess is that you are doing something else incorrect in your code... from StackOverflow it seems that some people got this exception by forgetting to close their cursors, for example. If you want to post a question on StackOverflow about this with your code, you can leave a link to the post as a reply here and I can take a look. :)</div>
</div>
<div class='comment'>
<div class='author'>Catalin Morosan</div>
<div class='content'>
Have you put this theory to the test? In my experience, you do need to synchronize even though you use SQLiteDatabase.<br /><br />In my app, I have a SyncAdapter which uses the ContentProvider to put data into the SQLiteDatabase. Everythint was working perfectly for months. After I have added a second way to update the ContentProvider from GCM push notifications, I start getting crash reports from some users like<br /><br />android.database.sqlite.SQLiteDiskIOException: disk I/O error (code 3850)<br /><br />OR<br /><br />android.database.sqlite.SQLiteDiskIOException: disk I/O error (code 778)<br /><br />and several other exceptions related to sqlite.<br /><br />And I haven&#39;t found a good solution yet.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
That sounds like the correct solution to me. The important thing to understand is that the ContentProvider won&#39;t do any of the synchronization for you. If your ContentProvider is backed by raw files, then you&#39;d need to serialize access to them yourself.</div>
</div>
<div class='comment'>
<div class='author'>David</div>
<div class='content'>
In my app, I had a ContentProvider backed by SQLite and filled by an IntentService, which downloaded stuff from the Internet. The ContentProvider was always triggered concurrently by the UI LoaderManagers (multiple Fragments calling the same data in an Activity).<br /><br />Synchronizing these ContentProvider calls made everything slower. Noticeably slower.<br /><br />However, the IntentService was being triggered twice, and any missing data would be marked to be downloaded twice. And inserted twice. At first, I used this answer:<br /><br />http://stackoverflow.com/a/8690698/489607<br /><br />And I&#39;m still using just in case, to avoid the ultimate deadly mistake of duplicated data. If anything, I can count on SQlite itself to safeguard it.<br /><br />But I still had to solve the duplicated (and discarded) downloads. To that, I implemented a single history of what was downloaded, together with a very simple database checker. If the second call asked for something that was included in the first call (and if not, if it was at least included in the db already), only the remaining stuff would be marked for download and inserted. Together with ContentProvider and Cursors, everything went perfectly fine.<br /><br />It&#39;s obviously doable, but at least to me, putting a ContentProvider together with Services and UIs, and orchestrating all of that together is not exactly trivial (especially when you need notifications and track loading states between all this), and I admit sometimes I have no idea of what happens behind the scenes.<br /><br />But since I&#39;m not wasting users mobile data or inserting duplicated entries, while still enjoying speedy multithreaded queries, it&#39;s OK in my book! :-)</div>
</div>
<div class='comment'>
<div class='author'>snicolas</div>
<div class='content'>
If there is a race condition for files, a solution can be to always use FileLock to protect file operation within CPs.<br /><br />Can someone look into this ?</div>
</div>
</div>
