---           
layout: post
title: FragmentTransactions & Activity State Loss
date: 2013-12-21 14:21:03 UTC
updated: 2013-12-21 14:21:03 UTC
comments: false
categories: 
---
 
<p>The following stack trace and exception message has plagued StackOverflow ever since Honeycomb's initial release: </p> <p><pre class="brush: plain">java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState<br />    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)<br />    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)<br />    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)<br />    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)<br /></pre></p> <p>This post will explain <i>why</i> and <i>when</i> this exception is thrown, and will conclude with several suggestions that will help ensure it never crashes your application again. </p> <h4>Why was the exception thrown? </h4> <p>The exception was thrown because you attempted to commit a <code>FragmentTransaction</code> after the activity's state had been saved, resulting in a phenomenon known as <i>Activity state loss</i>. Before we get into the details of what this actually means, however, let's first take a look at what happens under-the-hood when <code>onSaveInstanceState()</code> is called. As I discussed in my last post about <a href="http://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html"><code>Binder</code>'s &amp; Death Recipients</a>, Android applications have very little control over their destiny within the Android runtime environment. The Android system has the power to terminate processes at any time to free up memory, and background activities may be killed with little to no warning as a result. To ensure that this sometimes erratic behavior remains hidden from the user, the framework gives each Activity a chance to save its state by calling its <code>onSaveInstanceState()</code> method before making the Activity vulnerable to destruction. When the saved state is later restored, the user will be given the perception that they are seamlessly switching between foreground and background activities, regardless of whether or not the Activity had been killed by the system. </p> <p>When the framework calls <code>onSaveInstanceState()</code>, it passes the method a <code>Bundle</code> object for the Activity to use to save its state, and the Activity records in it the state of its dialogs, fragments, and views. When the method returns, the system parcels the <code>Bundle</code> object across a Binder interface to the System Server process, where it is safely stored away. When the system later decides to recreate the Activity, it sends this same <code>Bundle</code> object back to the application, for it to use to restore the Activity's old state. </p> <p>So why then is the exception thrown? Well, the problem stems from the fact that these <code>Bundle</code> objects represent a snapshot of an Activity at the moment <code>onSaveInstanceState()</code> was called, and nothing more. That means when you call <code>FragmentTransaction#commit()</code> after <code>onSaveInstanceState()</code> is called, the transaction won't be remembered because it was never recorded as part of the Activity's state in the first place. From the user's point of view, the transaction will appear to be lost, resulting in accidental UI state loss. In order to protect the user experience, Android avoids state loss at all costs, and simply throws an <code>IllegalStateException</code> whenever it occurs. </p> <a name='more'></a> <h4>When is the exception thrown? </h4> <p>If you've encountered this exception before, you've probably noticed that the moment when it is thrown is slightly inconsistent across different platform versions. For example, you probably found that older devices tended to throw the exception less frequently, or that your application was more likely to crash when using the support library than when using the official framework classes. These slight inconsistencies have led many to assume that the support library is buggy and can't be trusted. These assumptions, however, are generally not true. </p> <p>The reason why these slight inconsistencies exist stems from a significant change to the Activity lifecycle that was made in Honeycomb. Prior to Honeycomb, Activities were not considered killable until after they had been paused, meaning that <code>onSaveInstanceState()</code> was called immediately before <code>onPause()</code>. Beginning with Honeycomb, however, Activities are considered to be killable only after they have been <i>stopped</i>, meaning that <code>onSaveInstanceState()</code> will now be called before <code>onStop()</code> instead of immediately before <code>onPause()</code>. These differences are summarized in the table below: </p> <table border="1" cellpadding="5">  <tbody><tr>    <th style="width: 270px"></th>    <th>pre-Honeycomb</th>    <th>post-Honeycomb</th>  </tr>  <tr>    <td style="width: 270px">Activities can be killed before <code>onPause()</code>?</td>    <td>NO</td>    <td>NO</td>  </tr>  <tr>    <td style="width: 270px">Activities can be killed before <code>onStop()</code>?</td>    <td>YES</td>    <td>NO</td>  </tr>  <tr>    <td style="width: 270px"><code>onSaveInstanceState(Bundle)</code> is guaranteed to be called before...</td>    <td><code>onPause()</code></td>    <td><code>onStop()</code></td>  </tr></tbody></table> <p>As a result of the slight changes that were made to the Activity lifecycle, the support library sometimes needs to alter its behavior depending on the platform version. For example, on Honeycomb devices and above, an exception will be thrown each and every time a <code>commit()</code> is called after&nbsp;<code>onSaveInstanceState()</code> to warn the developer that state loss has occurred. However, throwing an exception every time this happened would be too restrictive on pre-Honeycomb devices, which have their <code>onSaveInstanceState()</code> method called much earlier in the Activity lifecycle and are more vulnerable to accidental state loss as a result. The Android team was forced to make a compromise: for better inter-operation with older versions of the platform, older devices would have to live with the accidental state loss that might result between <code>onPause()</code> and <code>onStop()</code>. The support library's behavior across the two platforms is summarized in the table below: </p> <table border="1" cellpadding="5">  <tbody><tr>    <th style="width: 270px"></th>    <th>pre-Honeycomb</th>    <th>post-Honeycomb</th>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> before <code>onPause()</code></td>    <td>OK</td>    <td>OK</td>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> between <code>onPause()</code> and <code>onStop()</code></td>    <td>STATE LOSS</td>    <td>OK</td>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> after <code>onStop()</code></td>    <td>EXCEPTION</td>    <td>EXCEPTION</td>  </tr></tbody></table> <h4>How to avoid the exception? </h4> <p>Avoiding Activity state loss becomes a whole lot easier once you understand what is actually going on. If you've made it this far in the post, hopefully you understand a little better how the support library works and why it is so important to avoid state loss in your applications. In case you've referred to this post in search of a quick fix, however, here are some suggestions to keep in the back of your mind as you work with <code>FragmentTransaction</code>s in your applications: </p> <ul> <li><p><b>Be careful when committing transactions inside Activity lifecycle methods.</b> A large majority of applications will only ever commit transactions the very first time <code>onCreate()</code> is called and/or in response to user input, and will never face any problems as a result. However, as your transactions begin to venture out into the other Activity lifecycle methods, such as <code>onActivityResult()</code>, <code>onStart()</code>, and <code>onResume()</code>, things can get a little tricky. For example, you should not commit transactions inside the <code>FragmentActivity#onResume()</code> method, as there are some cases in which the method can be called before the activity's state has been restored (see the <a href="http://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume()">documentation</a> for more information). If your application requires committing a transaction in an Activity lifecycle method other than <code>onCreate()</code>, do it in either <code>FragmentActivity#onResumeFragments()</code> or <code>Activity#onPostResume()</code>. These two methods are guaranteed to be called after the Activity has been restored to its original state, and therefore avoid the possibility of state loss all together. (As an example of how this can be done, check out my answer to <a href="http://stackoverflow.com/q/16265733/844882">this StackOverflow question</a> for some ideas on how to commit <code>FragmentTransaction</code>s in response to calls made to the <code>Activity#onActivityResult()</code> method). </p></li> <li><p><b>Avoid performing transactions inside asynchronous callback methods.</b> This includes commonly used methods such as <code>AsyncTask#onPostExecute()</code> and <code>LoaderManager.LoaderCallbacks#onLoadFinished()</code>. The problem with performing transactions in these methods is that they have no knowledge of the current state of the Activity lifecycle when they are called. For example, consider the following sequence of events: </p> <ol><li value="1">An activity executes an <code>AsyncTask</code>.</li><li value="2">The user presses the "Home" key, causing the activity's <code>onSaveInstanceState()</code> and <code>onStop()</code> methods to be called.</li>  <li value="3">The <code>AsyncTask</code> completes and <code>onPostExecute()</code> is called, unaware that the Activity has since been stopped.</li><li value="4">A <code>FragmentTransaction</code> is committed inside the <code>onPostExecute()</code> method, causing an exception to be thrown.</li></ol> <p>In general, the best way to avoid the exception in these cases is to simply avoid committing transactions in asynchronous callback methods all together. Google engineers seem to agree with this belief as well. According to <a href="https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ">this post</a> on the Android Developers group, the Android team considers the major shifts in UI that can result from committing <code>FragmentTransaction</code>s from within asynchronous callback methods to be bad for the user experience. If your application requires performing the transaction inside these callback methods and there is no easy way to guarantee that the callback won't be invoked after <code>onSaveInstanceState()</code>, you may have to resort to using <code>commitAllowingStateLoss()</code> and dealing with the state loss that might occur. (See also these two StackOverflow posts for additional hints, <a href="http://stackoverflow.com/q/8040280/844882">here</a> and <a href="http://stackoverflow.com/q/7992496/844882">here</a>). </p></li> <li><p><b>Use <code>commitAllowingStateLoss()</code> only as a last resort.</b> The only difference between calling <code>commit()</code> and <code>commitAllowingStateLoss()</code> is that the latter will not throw an exception if state loss occurs. Usually you don't want to use this method because it implies that there is a possibility that state loss could happen. The better solution, of course, is to write your application so that <code>commit()</code> is guaranteed to be called before the activity's state has been saved, as this will result in a better user experience. Unless the possibility of state loss can't be avoided, <code>commitAllowingStateLoss()</code> should not be used. </p></li> </ul> <p>Hopefully these tips will help you resolve any issues you have had with this exception in the past. If you are still having trouble, post a question on <a href="http://stackoverflow.com">StackOverflow</a> and post a link in a comment below and I can take a look. :) </p> <p>As always, thanks for reading, and leave a comment if you have any questions. Don't forget to +1 this blog and share this post on Google+ if you found it interesting! </p><img src="http://feeds.feedburner.com/~r/androiddesignpatterns/~4/p8Xy5z5G8b0" height="1" width="1"/>