---           
layout: post
title: Designing for Backwards Compatibility
date: 2012-08-26 19:08:42 UTC
updated: 2012-08-26 19:08:42 UTC
comments: false
categories: 
---
 
<p>A common issue in Android development is backwards compatibility. How can we add cool new features from the most recent Android API while still ensuring that it runs correctly on devices running older versions of Android? This post discusses the problem by means of a simple example, and proposes a scalable, well-designed solution.</p> <p>(Note: please read this <a href="http://www.androiddesignpatterns.com/2012/06/compatability-manager-utility-class.html">short post</a> before continuing forward).</p> <h4>The Problem</h4> <p>Let's say we are writing an application that reads and writes pictures to new albums (i.e. folders) located on external storage, and that we want our application to support all devices running Donut (Android 1.6, SDK version 4) and above. Upon consulting the <a href="http://developer.android.com/guide/topics/data/data-storage.html#filesExternal">documentation</a>, we realize there is a slight problem. With the introduction of Froyo (Android 2.2, SDK version 8) came a somewhat radical change in how external storage was laid out and represented on Android devices, as well as several new API methods (see <span style="font-family: 'Courier New', Courier, monospace;"><a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CGYQFjAA&amp;url=http%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fos%2FEnvironment.html&amp;ei=xoDWT8mwIPT16AGB--WjAw&amp;usg=AFQjCNHE5XowVrjv9ck6qWBJlAOX6S3Vaw">android.os.Environment</a></span>) that allow us access to the public storage directories. To ensure backwards compatibility all the way back to Donut, we must provide two separate implementations: one for older, pre-Froyo devices, and another for devices running Froyo and above.</p> <h4>Setting up the Manifest</h4> <p>Before we dive into the implementation, we will first update our <span style="font-family: 'Courier New', Courier, monospace;">uses-sdk</span> tag in the Android manifest. There are two attributes we must set,</p> <ul><li><span style="font-family: 'Courier New', Courier, monospace;">android:minSdkVersion="4"</span>. This attribute defines a minimum API level required for the application to run. We want our application to run on devices running Donut and above, so we set its value to <span style="font-family: 'Courier New', Courier, monospace;">"4"</span>.</li><li><span style="font-family: 'Courier New', Courier, monospace;">android:targetSdkVersion="15"</span>. This attribute is a little trickier to understand (and is incorrectly defined on blogs all over the internet). This attribute specifies the API level on which the application is designed to run. Preferably we would want its value to correspond to the most recently released SDK (<span style="font-family: 'Courier New', Courier, monospace;">"15"</span>, at the time of this posting). Strictly speaking, however, its value should be given by the largest SDK version number that we have tested your application against (we will assume we have done so for the remainder of this example).</li></ul><a name='more'></a> <p>The resulting tag in our mainfest is as follows:</p>   <p><pre class="brush: java"><br />&lt;uses-sdk <br />    android:minSdkVersion="4"<br />    android:targetSdkVersion="15" &gt;<br />&lt;/uses-sdk&gt;<br /></pre></p> <h4>Implementation</h4> <p>Our implementation will consist of an abstract class and two subclasses that extend it. The abstract <span style="font-family: 'Courier New', Courier, monospace;">AlbumStorageDirFactory</span> class enforces a simple contract by requiring its subclasses to implement the <span style="font-family: 'Courier New', Courier, monospace;">getAlbumStorageDir</span> method. The actual implementation of this method depends on the device's SDK version number. Specifically, if we are using a device running Froyo or above, its implementation will make use of new methods introduced in API level 8. Otherwise, the correct directory must be determined using pre-Froyo method calls, to ensure that our app remains backwards compatible.</p> <p><pre class="brush: java">public abstract class AlbumStorageDirFactory {<br /><br />  /**<br />   * Returns a File object that points to the folder that will store <br />   * the album's pictures. <br />   */<br />  public abstract File getAlbumStorageDir(String albumName);<br /><br />  /**<br />   * A static factory method that returns a new AlbumStorageDirFactory <br />   * instance based on the current device's SDK version.<br />   */<br />  public static AlbumStorageDirFactory newInstance() {<br />    // Note: the CompatibilityUtil class is implemented <br />    // and discussed in a previous post, entitled <br />    // "Ensuring Compatibility with a Utility Class".<br />    if (CompatabilityUtil.isFroyo()) {<br />      return new FroyoAlbumDirFactory();<br />    } else {<br />      return new BaseAlbumDirFactory();<br />    }<br />  }<br />}<br /></pre></p> <p>The two subclasses and their implementation are given below.The class also provides a static factory <span style="font-family: 'Courier New', Courier, monospace;">newInstance</span> method (note that this method makes use of the <span style="font-family: 'Courier New', Courier, monospace;">CompatabilityUtil</span> utility class, which was both implemented and discussed in a <a href="http://www.androiddesignpatterns.com/2012/06/compatability-manager-utility-class.html">previous post</a>). We discuss this method in detail in the next section.</p> <p>The <span style="font-family: 'Courier New', Courier, monospace;">BaseAlbumDirFactory</span> subclass handles pre-Froyo SDK versions:</p> <p><pre class="brush: java"><br />public class BaseAlbumDirFactory extends AlbumStorageDirFactory {<br /><br />  /**<br />   * For pre-Froyo devices, we must provide the name of the photo directory <br />   * ourselves. We choose "/dcim/" as it is the widely considered to be the <br />   * standard storage location for digital camera files.<br />   */<br />  private static final String CAMERA_DIR = "/dcim/";<br /><br />  @Override<br />  public File getAlbumStorageDir(String albumName) {<br />    return new File (<br />                    Environment.getExternalStorageDirectory() <br />                    + CAMERA_DIR <br />                    + albumName<br />    );<br />  }<br />}<br /></pre></p> <p>The <span style="font-family: 'Courier New', Courier, monospace;">FroyoAlbumDirFactory</span> subclass handles Froyo and above:</p> <p><pre class="brush: java"><br />public class FroyoAlbumDirFactory extends AlbumStorageDirFactory {<br /><br />  @Override<br />  public File getAlbumStorageDir(String albumName) {<br />    return new File(<br />        Environment.getExternalStoragePublicDirectory(<br />            Environment.DIRECTORY_PICTURES<br />        ), <br />        albumName<br />    );<br />  }<br />}<br /></pre></p> <h4>Making Sense of the Pattern</h4> <p>Take a second to study the structure of the code above. Our implementation ensures compatibility with pre-Froyo devices through a simple design. To ensure compatibility, we simply request a new <span style="font-family: 'Courier New', Courier, monospace;">AlbumStorageDirFactory</span> and call the abstract <span style="font-family: 'Courier New', Courier, monospace;">getAlbumStorageDir</span> method. The subclass is determined and instantiated at runtime depending on the Android device's SDK version number. See the sample activity below for an example on how an ordinary Activity might use this pattern to retrieve an album's directory.</p> <p><pre class="brush: java"><br />public class SampleActivity extends Activity {<br /><br />  private AlbumStorageDirFactory mAlbumFactory;<br /><br />  @Override<br />  public void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br /><br />    // Instantiate the AlbumStorageDirFactory. Instead of<br />    // invoking the subclass' default constructors directly,<br />    // we make use of the Abstract Factory design pattern,<br />    // which encapsulates the inner details. As a result, the<br />    // Activity does not need to know `anything` about the<br />    // compatibility-specific implementation--all of this is<br />    // done behind the scenes within the "mAlbumFactory" object.     <br />    mAlbumFactory = AlbumStorageDirFactory.newInstance();<br /><br />    // get the album's directory<br />    File sampleAlbumDir = getAlbumDir("sample_album");<br />  }<br /><br />  /**<br />   * A simple helper method that returns a File corresponding<br />   * to the album named "albumName". The helper method invokes<br />   * the abstract "getAlbumStorageDir" method, which will return<br />   * correct location of the directory depending on the subclass<br />   * that was returned in "newInstance" (which depends entirely<br />   * on the device's SDK version number).<br />   */<br />  private File getAlbumDir(String albumName) {<br />    return mAlbumStorageDirFactory.getAlbumStorageDir(albumName);<br />  }<br />}<br /></pre></p> <p>There are a couple benefits to organizing the code the way we have:</p> <ul><li><b>It's easily extendable.</b> While there is certainly no need to separate our implementations into classes for simple examples (such as the one discussed above), doing so is important when working with large, complicated projects, as it will ensure changes can quickly be made down the line.</li><li><b>It encapsulates the implementation-specific details.</b> Abstracting these details from the client makes our code less cluttered and easier to read (note: in this case, "the client" was the person who wrote the Activity class).</li></ul> <h4>Conclusion</h4> <p>Android developers constantly write code to ensure backwards compatibility. As projects expand and applications become more complex, it becomes increasingly important to ensure your implementation is properly designed. Hopefully this post helped and will encourage you to more elegant solutions in the future!</p> <p>Leave a comment if you have any questions or criticisms... or just to let me know that you managed to read through this entire post without getting distracted!</p><img src="http://feeds.feedburner.com/~r/androiddesignpatterns/~4/Yyr27HfXuwc" height="1" width="1"/>