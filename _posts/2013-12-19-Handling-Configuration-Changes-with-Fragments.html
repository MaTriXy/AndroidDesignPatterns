---           
layout: post
title: Handling Configuration Changes with Fragments
date: 2013-12-19 18:15:13 UTC
updated: 2013-12-19 18:15:13 UTC
comments: false
categories: 
---
 
<p>This post addresses a common question: <i>what is the best way to retain active objects—such as running </i><code>Thread</code><i>s, </i><code>Socket</code><i>s, and </i><code>AsyncTask</code><i>s—across device configuration changes?</i></p> <p>To answer this question, we will first discuss some of the common difficulties developers face when using long-running background tasks in conjunction with the Activity lifecycle. Then, we will describe the flaws of two common approaches to solving the problem. Finally, we will conclude with sample code illustrating the recommended solution, which uses retained Fragments to achieve our goal.</p> <h4>Configuration Changes & Background Tasks</h4> <p>One problem with configuration changes and the destroy-and-create cycle that Activitys go through as a result stems from the fact that these events are unpredictable and may occur at any time. Concurrent background tasks only add to this problem. Assume, for example, that an Activity starts an <code>AsyncTask</code> and soon after the user rotates the screen, causing the Activity to be destroyed and recreated. When the <code>AsyncTask</code> eventually finishes its work, it will incorrectly report its results back to the old Activity instance, completely unaware that a new Activity has been created. As if this wasn't already an issue, the new Activity instance might waste valuable resources by firing up the background work <i>again</i>, unaware that the old <code>AsyncTask</code> is still running. For these reasons, it is vital that we correctly and efficiently retain active objects across Activity instances when configuration changes occur.</p> <a name='more'></a> <h4>Bad Practice: Retain the Activity</h4> <p>Perhaps the hackiest and most widely abused workaround is to disable the default destroy-and-recreate behavior by setting the <code>android:configChanges</code> attribute in your Android manifest. The apparent simplicity of this approach makes it extremely attractive to developers; <a href="http://stackoverflow.com/a/5336057/844882">Google engineers</a>, however, discourage its use. The primary concern is that it requires you to handle device configuration changes manually in code. Handling configuration changes requires you to take many additional steps to ensure that each and every string, layout, drawable, dimension, etc. remains in sync with the device's current configuration, and if you aren't careful, your application can easily have a whole series of resource-specific bugs as a result.</p> <p>Another reason why Google discourages its use is because many developers incorrectly assume that setting <code>android:configChanges="orientation"</code> (for example) will magically protect their application from unpredictable scenarios in which the underlying Activity will be destroyed and recreated. <i>This is not the case.</i> Configuration changes can occur for a number of reasons&mdash;not just screen orientation changes. Inserting your device into a display dock, changing the default language, and modifying the device's default font scaling factor are just three examples of events that can trigger a device configuration change, all of which signal the system to destroy and recreate all currently running Activitys the next time they are resumed. As a result, setting the <code>android:configChanges</code> attribute is generally not good practice.</p> <h4>Deprecated: Override <code>onRetainNonConfigurationInstance()</code></h4> <p>Prior to Honeycomb's release, the recommended means of transferring active objects across Activity instances was to override the <code>onRetainNonConfigurationInstance()</code> and <code>getLastNonConfigurationInstance()</code> methods. Using this approach, transferring an active object across Activity instances was merely a matter of returning the active object in <code>onRetainNonConfigurationInstance()</code> and retrieving it in <code>getLastNonConfigurationInstance()</code>. As of API 13, these methods have been deprecated in favor of the more Fragment's <code>setRetainInstance(boolean)</code> capability, which provides a much cleaner and modular means of retaining objects during configuration changes. We discuss this Fragment-based approach in the next section.</p> <h4>Recommended: Manage the Object Inside a Retained <code>Fragment</code></h4> <p>Ever since the introduction of Fragments in Android 3.0, the recommended means of retaining active objects across Activity instances is to wrap and manage them inside of a retained "worker" Fragment. By default, Fragments are destroyed and recreated along with their parent Activitys when a configuration change occurs. Calling <code>Fragment#setRetainInstance(true)</code> allows us to bypass this destroy-and-recreate cycle, signaling the system to retain the current instance of the fragment when the activity is recreated. As we will see, this will prove to be extremely useful with Fragments that hold objects like running <code>Thread</code>s, <code>AsyncTask</code>s, <code>Socket</code>s, etc.</p> <p>The sample code below serves as a basic example of how to retain an <code>AsyncTask</code> across a configuration change using retained Fragments. The code guarantees that progress updates and results are delivered back to the currently displayed Activity instance and ensures that we never accidentally leak an <code>AsyncTask</code> during a configuration change. The design consists of two classes, a <code>MainActivity</code>...</p> <p><pre class="brush:java">/**<br /> * This Activity displays the screen's UI, creates a TaskFragment<br /> * to manage the task, and receives progress updates and results <br /> * from the TaskFragment when they occur.<br /> */<br />public class MainActivity extends Activity implements TaskFragment.TaskCallbacks {<br /><br />  private TaskFragment mTaskFragment;<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br />    setContentView(R.layout.main);<br /><br />    FragmentManager fm = getFragmentManager();<br />    mTaskFragment = (TaskFragment) fm.findFragmentByTag("task");<br /><br />    // If the Fragment is non-null, then it is currently being<br />    // retained across a configuration change.<br />    if (mTaskFragment == null) {<br />      mTaskFragment = new TaskFragment();<br />      fm.beginTransaction().add(mTaskFragment, "task").commit();<br />    }<br /><br />    // TODO: initialize views, restore saved state, etc.<br />  }<br /><br />  // The four methods below are called by the TaskFragment when new<br />  // progress updates or results are available. The MainActivity <br />  // should respond by updating its UI to indicate the change.<br /><br />  @Override<br />  public void onPreExecute() { ... }<br /><br />  @Override<br />  public void onProgressUpdate(int percent) { ... }<br /><br />  @Override<br />  public void onCancelled() { ... }<br /><br />  @Override<br />  public void onPostExecute() { ... }<br />}</pre> <p>...and a <code>TaskFragment</code>...</p> <p><pre class="brush:java">/**<br /> * This Fragment manages a single background task and retains <br /> * itself across configuration changes.<br /> */<br />public class TaskFragment extends Fragment {<br /><br />  /**<br />   * Callback interface through which the fragment will report the<br />   * task's progress and results back to the Activity.<br />   */<br />  public static interface TaskCallbacks {<br />    void onPreExecute();<br />    void onProgressUpdate(int percent);<br />    void onCancelled();<br />    void onPostExecute();<br />  }<br /><br />  private TaskCallbacks mCallbacks;<br />  private DummyTask mTask;<br /><br />  /**<br />   * Hold a reference to the parent Activity so we can report the<br />   * task's current progress and results. The Android framework <br />   * will pass us a reference to the newly created Activity after <br />   * each configuration change.<br />   */<br />  @Override<br />  public void onAttach(Activity activity) {<br />    super.onAttach(activity);<br />    mCallbacks = (TaskCallbacks) activity;<br />  }<br /><br />  /**<br />   * This method will only be called once when the retained<br />   * Fragment is first created.<br />   */<br />  @Override<br />  public void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br /><br />    // Retain this fragment across configuration changes.<br />    setRetainInstance(true);<br /><br />    // Create and execute the background task.<br />    mTask = new DummyTask();<br />    mTask.execute();<br />  }<br /><br />  /**<br />   * Set the callback to null so we don't accidentally leak the <br />   * Activity instance.<br />   */<br />  @Override<br />  public void onDetach() {<br />    super.onDetach();<br />    mCallbacks = null;<br />  }<br /><br />  /**<br />   * A dummy task that performs some (dumb) background work and<br />   * proxies progress updates and results back to the Activity.<br />   *<br />   * Note that we need to check if the callbacks are null in each<br />   * method in case they are invoked after the Activity's and<br />   * Fragment's onDestroy() method have been called.<br />   */<br />  private class DummyTask extends AsyncTask&lt;Void, Integer, Void&gt; {<br /><br />    @Override<br />    protected void onPreExecute() {<br />      if (mCallbacks != null) {<br />        mCallbacks.onPreExecute();<br />      }<br />    }<br /><br />    /**<br />     * Note that we do NOT call the callback object's methods<br />     * directly from the background thread, as this could result <br />     * in a race condition.<br />     */<br />    @Override<br />    protected Void doInBackground(Void... ignore) {<br />      for (int i = 0; !isCancelled() && i < 100; i++) {<br />        SystemClock.sleep(100);<br />        publishProgress(i);<br />      }<br />      return null;<br />    }<br /><br />    @Override<br />    protected void onProgressUpdate(Integer... percent) {<br />      if (mCallbacks != null) {<br />        mCallbacks.onProgressUpdate(percent[0]);<br />      }<br />    }<br /><br />    @Override<br />    protected void onCancelled() {<br />      if (mCallbacks != null) {<br />        mCallbacks.onCancelled();<br />      }<br />    }<br /><br />    @Override<br />    protected void onPostExecute(Void ignore) {<br />      if (mCallbacks != null) {<br />        mCallbacks.onPostExecute();<br />      }<br />    }<br />  }<br />}</pre></p> <h4>Flow of Events</h4> <p>When the <code>MainActivity</code> starts up for the first time, it instantiates and adds the <code>TaskFragment</code> to the Activity's state. The <code>TaskFragment</code> creates and executes an <code>AsyncTask</code> and proxies progress updates and results back to the <code>MainActivity</code> via the <code>TaskCallbacks</code> interface. When a configuration change occurs, the <code>MainActivity</code> goes through its normal lifecycle events, and once created the new Activity instance is passed to the <code>onAttach(Activity)</code> method, thus ensuring that the <code>TaskFragment</code> will always hold a reference to the currently displayed Activity instance even after the configuration change. The resulting design is both simple and reliable; the application framework will handle re-assigning Activity instances as they are torn down and recreated, and the <code>TaskFragment</code> and its <code>AsyncTask</code> never need to worry about the unpredictable occurrence of a configuration change.</p> <!--<h4>Race Conditions and Memory Leaks</h4> For the most part, implementing background tasks using retained Fragments should be fairly straight forward. However, it is possible to inadvertently introduce race conditions and/or memory leaks into your application if you aren't careful:  <ul> <li><p><b>Race conditions.</b> Make sure you don't call the Activity callback's methods from a background thread, as this can result in race conditions. For example, if the background task finishes and calls one of the callback's methods from a background thread between <code>Fragment#onDetach()</code> and <code>Fragment#onAttach(Activity)</code>, the Activity instance that will actually receive the result will be undefined. For this reason, you must <i>only</i> make calls to the Activity callback instance on the main UI thread. <code>AsyncTask</code>s do most of this work for you already. If you were to use a <code>Thread</code>, however, you'd need to do some extra work to synchronize with the main thread. </p></li> <li><p><b>Memory leaks.</b> If your Fragment holds a reference to the Activity as a callback object (as shown in the example code above), you should be extra careful that you don't accidentally leak the Activity instance. How this can be done depends on your implementation, but usually it is a matter of simply setting the callback object to <code>null</code> in <code>Fragment#onDestroy()</code>.  </p></li> </ul>--> <h4>Conclusion</h4> <p>Synchronizing background tasks with the Activity lifecycle can be tricky and configuration changes will only add to the confusion. Fortunately, retained Fragments make handling these events very easy by consistently maintaining a reference to its parent Activity, even after being destroyed and recreated.</p> <p>A sample application illustrating how to correctly use retained Fragments to achieve this effect is available for download on the <a href="https://play.google.com/store/apps/details?id=com.adp.retaintask">Play Store</a>. The source code is available on <a href="https://github.com/alexjlockwood/worker-fragments">GitHub</a>. Download it, import it into Eclipse, and modify it all you want!</p> <p><a href="https://play.google.com/store/apps/details?id=com.adp.retaintask" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-1sQZ32vpOy4/UXtjWSjLhfI/AAAAAAAAHJw/KoXS-a5y3mo/s320/Screenshot_2013-04-27-04-22-18.png" /></a></p> <p>As always, leave a comment if you have any questions and don't forget to +1 this blog in the top right corner!</p><img src="http://feeds.feedburner.com/~r/androiddesignpatterns/~4/QO-QOO5oX98" height="1" width="1"/>