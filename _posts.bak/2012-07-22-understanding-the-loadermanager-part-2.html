---
layout: post
title: Understanding the LoaderManager (part 2)
date: 2012-07-22
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>This post introduces the <code>LoaderManager</code> class. This is the second of a series of posts I will be writing on Loaders and the LoaderManager:</p> <ul><li><b>Part 1:</b> <a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html">Life Before Loaders</a></li><li><b>Part 2:</b> <a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html">Understanding the LoaderManager</a></li><li><b>Part 3:</b> <a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">Implementing Loaders</a></li><li><b>Part 4:</b> <a href="http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html">Tutorial: AppListLoader</a></li></ul> <p><b>Note:</b> Understanding the <code>LoaderManager</code> requires some general knowledge about how <code>Loader</code>s are work. Their implementation will be covered extensively in my <a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">next post</a>. For now, you should think of Loaders as simple, self-contained objects that (1) load data on a separate thread, and (2) monitor the underlying data source for updates, re-querying when changes are detected. This is more than enough to get you through the contents of this post. All Loaders are assumed to be 100% correctly implemented in this post.</p> <h4>What is the <code>LoaderManager</code>?</h4> <p>Simply stated, the <code>LoaderManager</code> is responsible for managing one or more <code>Loader</code>s associated with an Activity or Fragment. Each Activity and each Fragment has exactly one LoaderManager instance that is in charge of starting, stopping, retaining, restarting, and destroying its Loaders. These events are sometimes initiated directly by the client, by calling <code>initLoader()</code>, <code>restartLoader()</code>, or <code>destroyLoader()</code>. Just as often, however, these events are triggered by major Activity/Fragment lifecycle events. For example, when an Activity is destroyed, the Activity instructs its LoaderManager to destroy and close its Loaders (as well as any resources associated with them, such as a Cursor).</p> <p>The LoaderManager does not know how data is loaded, nor does it need to. Rather, the LoaderManager instructs its Loaders when to start/stop/reset their load, retaining their state across configuration changes and providing a simple interface for delivering results back to the client. In this way, the LoaderManager is a much more intelligent and generic implementation of the now-deprecated <code>startManagingCursor</code> method. While both manage data across the twists and turns of the Activity lifecycle, the LoaderManager is far superior for several reasons:</p> <a name='more'></a> <ul><li><p><b><code>startManagingCursor</code> manages Cursors, whereas the LoaderManager manages <code>Loader&lt;D&gt;</code> objects.</b> The advantage here is that <code>Loader&lt;D&gt;</code> is generic, where <code>D</code> is the container object that holds the loaded data. In other words, the data source doesn't have to be a Cursor; it could be a <code>List</code>, a <code>JSONArray</code>... anything. The LoaderManager is independent of the container object that holds the data and is much more flexible as a result.</p></li> <li><p><b>Calling <code>startManagingCursor</code> will make the Activity call <code>requery()</code> on the managed cursor.</b> As mentioned in the previous post, <code>requery()</code> is a potentially expensive operation that is performed on the main UI thread. Subclasses of the <code>Loader&lt;D&gt;</code> class, on the other hand, are expected to load their data asynchronously, so using the LoaderManager will never block the UI thread.</p></li> <li><p><b><code>startManagingCursor</code> does not retain the Cursor's state across configuration changes.</b> Instead, each time the Activity is destroyed due to a configuration change (a simple orientation change, for example), the Cursor is destroyed and must be requeried. The LoaderManager is much more intelligent in that it retains its Loaders' state across configuration changes, and thus doesn't need to requery its data.</p></li> <li><p><b>The LoaderManager provides seamless monitoring of data!</b> Whenever the Loader's data source is modified, the LoaderManager will receive a new asynchronous load from the corresponding Loader, and will return the updated data to the client. (Note: the LoaderManager will only be notified of these changes if the Loader is implemented correctly. We will discuss how to implement custom Loaders in <a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">part 3</a> of this series of posts).</p></li></ul> <p>If you feel overwhelmed by the details above, I wouldn't stress over it. The most important thing to take away from this is that the <i>LoaderManager makes your life easy.</i> It initializes, manages, and destroys Loaders for you, reducing both coding complexity and subtle lifecycle-related bugs in your Activitys and Fragments. Further, interacting with the LoaderManager involves implementing three simple callback methods. We discuss the <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> in the next section.</p> <h4>Implementing the <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> Interface</h4> <p>The <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> interface is a simple contract that the <code>LoaderManager</code> uses to report data back to the client. Each Loader gets its own callback object that the LoaderManager will interact with. This callback object fills in the gaps of the abstract <code>LoaderManager</code> implementation, telling it how to instantiate the Loader (<code>onCreateLoader</code>) and providing instructions when its load is complete/reset (<code>onLoadFinished</code> and <code>onLoadReset</code>, respectively). Most often you will implement the callbacks as part of the component itself, by having your Activity or Fragment implement the <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> interface:</p> <p><pre class="brush:java">public class SampleActivity extends Activity implements LoaderManager.LoaderCallbacks&lt;D&gt; {<br /><br />  public Loader&lt;D&gt; onCreateLoader(int id, Bundle args) { ... }<br /><br />  public void onLoadFinished(Loader&lt;D&gt; loader, D data) { ... }<br /><br />  public void onLoaderReset(Loader&lt;D&gt; loader) { ... }<br /><br />  /* ... */<br />}<br /></pre></p> <p>Once instantiated, the client passes the callbacks object ("<code>this</code>", in this case) as the third argument to the LoaderManager's <code>initLoader</code> method, and will be bound to the Loader as soon as it is created.</p> <p>Overall, implementing the <a href="http://developer.android.com/reference/android/app/LoaderManager.LoaderCallbacks.html">callbacks</a> is straightforward. Each callback method serves a specific purpose that makes interacting with the LoaderManager easy:</p> <ul> <li><p><b><code>onCreateLoader</code></b> simply returns a new <code>Loader</code>. The LoaderManager will call this method when it first creates the Loader.</p></li> <li><p><b><code>onLoadFinished</code></b> is called automatically when a Loader has finished its load. This method is typically where the client will update the application's UI with the loaded data. The client may (and should) assume that new data will be returned to this method each time new data is made available. Remember that it is the Loader's job to monitor the data source and to perform the actual asynchronous loads. The LoaderManager will receive these loads once they have completed, and then pass the result to the callback object's <code>onLoadFinished</code> method for the client (i.e. the Activity/Fragment) to use.</p></li> <li><p>Lastly, <b><code>onLoadReset</code></b> is called when the Loader's data is about to be reset. This method gives you the opportunity to remove any references to old data that may no longer be available.</p></li> </ul> <p>In the next section, we will discuss a commonly asked question from beginning Android developers: how to transition from outdated managed Cursors to the much more powerful LoaderManager.</p> <h4>Transitioning from Managed Cursors to the <code>LoaderManager</code></h4> <p>The code below is similar in behavior to the sample in my <a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html">previous post</a>. The difference, of course, is that it has been updated to use the LoaderManager. The <code>CursorLoader</code> ensures that all queries are performed asynchronously, thus guaranteeing that we won't block the UI thread. Further, the LoaderManager manages the <code>CursorLoader</code> across the Activity lifecycle, retaining its data on configuration changes and directing each new data load to the callback's <code>onLoadFinished</code> method, where the Activity is finally free to make use of the queried Cursor.</p> <p><pre class="brush:java">public class SampleListActivity extends ListActivity implements<br />    LoaderManager.LoaderCallbacks&lt;Cursor&gt; {<br /><br />  private static final String[] PROJECTION = new String[] { "_id", "text_column" };<br /><br />  // The loader's unique id. Loader ids are specific to the Activity or<br />  // Fragment in which they reside.<br />  private static final int LOADER_ID = 1;<br /><br />  // The callbacks through which we will interact with the LoaderManager.<br />  private LoaderManager.LoaderCallbacks&lt;Cursor&gt; mCallbacks;<br /><br />  // The adapter that binds our data to the ListView<br />  private SimpleCursorAdapter mAdapter;<br /><br />  @Override<br />  public void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br /><br />    String[] dataColumns = { "text_column" };<br />    int[] viewIDs = { R.id.text_view };<br /><br />    // Initialize the adapter. Note that we pass a 'null' Cursor as the<br />    // third argument. We will pass the adapter a Cursor only when the<br />    // data has finished loading for the first time (i.e. when the<br />    // LoaderManager delivers the data to onLoadFinished). Also note<br />    // that we have passed the '0' flag as the last argument. This<br />    // prevents the adapter from registering a ContentObserver for the<br />    // Cursor (the CursorLoader will do this for us!).<br />    mAdapter = new SimpleCursorAdapter(this, R.layout.list_item,<br />        null, dataColumns, viewIDs, 0);<br /><br />    // Associate the (now empty) adapter with the ListView.<br />    setListAdapter(mAdapter);<br /><br />    // The Activity (which implements the LoaderCallbacks&lt;Cursor&gt;<br />    // interface) is the callbacks object through which we will interact<br />    // with the LoaderManager. The LoaderManager uses this object to<br />    // instantiate the Loader and to notify the client when data is made<br />    // available/unavailable.<br />    mCallbacks = this;<br /><br />    // Initialize the Loader with id '1' and callbacks 'mCallbacks'.<br />    // If the loader doesn't already exist, one is created. Otherwise,<br />    // the already created Loader is reused. In either case, the<br />    // LoaderManager will manage the Loader across the Activity/Fragment<br />    // lifecycle, will receive any new loads once they have completed,<br />    // and will report this new data back to the 'mCallbacks' object.<br />    LoaderManager lm = getLoaderManager();<br />    lm.initLoader(LOADER_ID, null, mCallbacks);<br />  }<br /><br />  @Override<br />  public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {<br />    // Create a new CursorLoader with the following query parameters.<br />    return new CursorLoader(SampleListActivity.this, CONTENT_URI,<br />        PROJECTION, null, null, null);<br />  }<br /><br />  @Override<br />  public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) {<br />    // A switch-case is useful when dealing with multiple Loaders/IDs<br />    switch (loader.getId()) {<br />      case LOADER_ID:<br />        // The asynchronous load is complete and the data<br />        // is now available for use. Only now can we associate<br />        // the queried Cursor with the SimpleCursorAdapter.<br />        mAdapter.swapCursor(cursor);<br />        break;<br />    }<br />    // The listview now displays the queried data.<br />  }<br /><br />  @Override<br />  public void onLoaderReset(Loader&lt;Cursor&gt; loader) {<br />    // For whatever reason, the Loader's data is now unavailable.<br />    // Remove any references to the old data by replacing it with<br />    // a null Cursor.<br />    mAdapter.swapCursor(null);<br />  }<br />}<br /></pre></p> <h4>Conclusion</h4> <p>As its name suggests, the <code>LoaderManager</code> is responsible for managing <code>Loader</code>s across the Activity/Fragment lifecycle. The LoaderManager is simple and its implementation usually requires very little code. The tricky part is implementing the Loaders, the topic of the next post: <a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">Implementing Loaders (part 3)</a>.</p> <p>Leave a comment if you have any questions... or just to let me know if this post helped or not! Don't forget to +1 this blog in the top right corner too! :)</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I would use a background Service. See <a href="http://www.youtube.com/watch?v=xHXn3Kg2IQE" rel="nofollow">this Google I/O talk</a> for some excellent hints about how to retrieve data from the web in the background.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Can we use AsyncTaskLoader to fetch large amount of data using webservice? Or is it better to use AsyncTask only?</div>
</div>
<div class='comment'>
<div class='author'>Jorge Ramirez</div>
<div class='content'>
:) Great article</div>
</div>
<div class='comment'>
<div class='author'>Warlock</div>
<div class='content'>
Great post! But I have problem with configuration change/lifecycle of Fragment - can you have a look here? Thanks! http://stackoverflow.com/questions/18727414/when-call-initloader-in-fragment</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
hahaha, thanks!<br /><br />If Google releases a +1000000 button, I will gladly include it in the blog. :)</div>
</div>
<div class='comment'>
<div class='author'>JF</div>
<div class='content'>
Totally agree. The +1 is clicked but where is the +1000000 ?</div>
</div>
<div class='comment'>
<div class='author'>uri</div>
<div class='content'>
Or you could have inner static classes, one for each loader (and have variables that point to these classes in your activity). I tend to prefer this technique over conditional statements.<br /><br />BTW, this is an awesome post. I understand Loaders thanks to this now.</div>
</div>
<div class='comment'>
<div class='author'>Gabriel Ponce</div>
<div class='content'>
You are the MAN! Thanks! It makes so much sense now :D</div>
</div>
<div class='comment'>
<div class='author'>David COHEN</div>
<div class='content'>
Hi Alex, <br />Thanks for this post, really helpfull. I have a question : How would you do to manage screen orientation for an activity which implements loaders ?<br />I found different implementations : using a retained fragment as you recommand in your last post about config changes (but in my case i don&#39;t need fragment), and some people uses static attributes on their loaders (http://stackoverflow.com/questions/12009895/loader-restarts-on-orientation-change)<br />What&#39;s the good approch you think ?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
A few of the SimpleCursorAdapter constructors are now deprecated, but the SimpleCursorAdapter class is not... there is nothing wrong with using it as long as you use the constructor which isn&#39;t deprecated.<br /><br />You can use Loaders with an SQLite database using the <a href="https://github.com/commonsguy/cwac-loaderex" rel="nofollow">LoaderEx</a> library.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Maybe it&#39;s the placebo effect? Well, I guess it depends on what kind of data you are querying and how expensive the loads are, but in general the positives outweigh the negatives I think. :)</div>
</div>
<div class='comment'>
<div class='author'>Richard Michael</div>
<div class='content'>
Hi Alex, I am new in android development but keep learning.<br />SimpleCursorAdapter is obselete in the newest versions? How we can this affect your example?<br />Can I use your example to access my sqlite database and how?<br />I am sorry for my simple questions</div>
</div>
<div class='comment'>
<div class='author'>birkin</div>
<div class='content'>
Hi Alex,this is a helpful article. I got an android phone, but I think this system were getting slower when you use it!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
See part 4 of this series for a complete example. Not sure why you need to see it though... Loaders don&#39;t require any extra configuration or setup in the manifest...</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Would really be helpful if you showed you AndroidManifest.xml file too</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
It would have been something like this: &quot;content://com.package.name/table_name&quot;;<br /><br />Check out this <a href="http://developer.android.com/guide/topics/providers/content-provider-basics.html" rel="nofollow">link</a> for more information.<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I don&#39;t think you answered the actual question. What was your CONTENT_URI?</div>
</div>
<div class='comment'>
<div class='author'>Shannon Lee</div>
<div class='content'>
Alex you have literally saved my life. Thank you.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
It isn&#39;t a hack. You need to do that in order to have these notifications delivered to the cursor. :)<br /></div>
</div>
<div class='comment'>
<div class='author'>Brian</div>
<div class='content'>
Hi Alex, would you confirm one thing?  I followed your examples to create a cursor loader, but it wasn&#39;t recognizing and auto-updating my screen with changes from the db.  I finally came across a comment somewhere that suggested you must also go into you content provider&#39;s query method and add a call to cursor.setNotificationUri.  It is working now which is nice, but I want to make sure adding this call is necessary, instead of a hack that masks some other problem.<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Севар</div>
<div class='content'>
10x Alex, your blog is excellent and this article is especially good and helpful! I was really frustrated that Loader didn&#39;t help in my case, but causing me problems instead. And not just this but some defects of ArrayAdapter came in to play and the mess was incredible. Actually I did understand loaders a bit wrong. I didn&#39;t expect that they rely very much on the observer/observable (which i had not implemented) Without a call to onContentChanged() it reloads some old data on config change. In fact it is not just a loader (i erroneously assumed that it&#39;s purpose is to load the AT START, but it serves the data all the time). When I added observer stuff and call to onContentChanged() on each single data change across the activity - everything got working! In my case problem was a bit more complicated because I implemented my own loader that works with a result object that packs the data + [optional] exception that maybe is cought inside loadInBackground(). If anyone is interested:<br />http://pastebin.com/CX1nxBhp<br />http://pastebin.com/1MaaJnht</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
That was the goal of these posts... to understand how the f*ck it works. Hopefully it helped at least a little. :)<br /><br />By the way, if you think the documentation is bad now... good thing you weren&#39;t around when it first came out. The documentation was <i>absolutely terrible</i>... :/</div>
</div>
<div class='comment'>
<div class='author'>Севар</div>
<div class='content'>
The loader is crappy and works unpredictable especially on config changes. Though it looks good it&#39;s logic is not as expected and (surprise!) is not documented. This crap that Google may call documentation is just some useless comments which are obvious. One must trace into its source code to understand how the fck it works!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
[original post on September 4, 2012 3:24 AM]<br /><br />I should probably just take out that &quot;anonymous class&quot; thing... it might be more confusing than it is helpful.<br /><br />To instantiate multiple Loaders in one activity, you could have your Activity implement the LoaderManager.LoaderCallbacks (thus making your Activity the callbacks object that the LoaderManager will be interacting with), and then for each Loader you create, call initLoader(id, null, this). In order to distinguish which Loader is being created/loaded/reset, you could do a switch case on the Loader&#39;s id in the Activity&#39;s callback methods (i.e. by calling getId()). This is how I would do it at least... I just think it is a little bit easier to understand. :)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
[original post on August 20, 2012 8:44 AM]<br /><br />Android adapters use container objects to hold their data... ArrayAdapter uses an ArrayList, CursorAdapter uses a Cursor, etc. Therefore it is not possible to directly link your adapter with the database... there has to be a step in between.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
[original post on September 20, 2012 7:06 AM]<br /><br />Are you using the support package? If eclipse is failing to recognize getLoaderManager() it could be that it wants you to use getSupportLoaderManager() instead (i.e. if you are using a FragmentActivity instead of an Activity).<br /><br />Are you familiar with ContentProviders at all? Understanding what a &quot;CONTENT_URI&quot; is assumed throughout this post, but basically it&#39;s a Uri constant that you have to use in order to ask the ContentResolver to query your particular ContentProvider. Try reading the article on ContentProviders on the Android developers site... it&#39;s very good. And don&#39;t give up on this stuff... it&#39;s hard to grasp at first (I went through the same thing about a year ago) but it&#39;s worth understanding in the end ;)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
[original post on October 7, 2012 11:34 AM]<br /><br />Things to try:<br /><br />(1) Post a question on StackOverflow... it&#39;ll get answered faster than you think :)<br />(2) If you are using the support package, make sure you are extending FragmentActivity<br />(3) If you are using the support package, delete all of your import statements and re-import with &quot;Ctrl + Shift + O&quot; and make sure you select only the support package libraries.<br />(4) If you are using the support package with a FragmentActivity, make sure you are using &quot;getSupportLoaderManager()&quot;<br />(5) If you are using the support package with a Fragment, make sure you are using &quot;getLoaderManager()&quot;<br />(6) Run Android lint... it might help pin point the specific problem you&#39;re having.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
No problem, glad I could help!</div>
</div>
<div class='comment'>
<div class='author'>Miftahuddin Zuhdi</div>
<div class='content'>
hi Alex , thanks for tutorial , now after implementing LoaderManager in my application , i understand that loaderManager is very2 awesome and helpful . .<br /><br />and you&#39;re right &quot;it&#39;s hard to grasp at first but it&#39;s worth understanding in the end ;)&quot; ,<br /><br />Thanks. .. </div>
</div>
<div class='comment'>
<div class='author'>Arun Prasad</div>
<div class='content'>
Thanks a lot. Better than the official documentation!!!</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I am also getting the error:<br /><br />The method getLoaderManager() is undefined for the type MainActivity</div>
</div>
<div class='comment'>
<div class='author'>Lem Lordje Ko</div>
<div class='content'>
Great tutorial!<br />Is there a way my onLoadFinished() can react differently depending on whether it&#39;s called from a data update or not?</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hi may I also add what value did you assign for the CONTENT_URI? Thank you.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hi Alex, nice tutorial by the way. May I ask how did you define the getLoaderManager() Method? When I tried this in my project, I&#39;m having this error:<br />The method getLoaderManager() is undefined for the type SearchByNameProject.<br />Sorry Today was my first time to use a LoaderManager.<br />Thank you.</div>
</div>
<div class='comment'>
<div class='author'>teh.fonsi</div>
<div class='content'>
Thx for this great summary about loaders. Especially the part about the Loader ID helped me fixing a problem when managing Loaders from different Fragments!</div>
</div>
<div class='comment'>
<div class='author'>Michał K</div>
<div class='content'>
&quot;If you really wanted, you could also instantiate an anonymous class and hold a reference to the callbacks object in a private instance field like so (there&#39;s no reason to ever do this and just makes things more confusing in my opinion (...)&quot;<br /><br />And how would you instantiate multiple Loaders in one Activivty? This is the way I do it, so I&#39;d be glad to get to know a better way.</div>
</div>
<div class='comment'>
<div class='author'>androidsnippets</div>
<div class='content'>
Very helpful tutorial. I have one doubt regarding this, if you can clarify. Can we create an adapter that is directly linked to database??? means whatever changes i have made to the database should be reflected to the adapter. Suppose i have inserted 2 rows in a table then the adapter should be refreshed and two more items should added to it. Is this possible using SimpleCursor Adapter or CursorLoader ???? </div>
</div>
<div class='comment'>
<div class='author'>David Sowerby</div>
<div class='content'>
Thank you, this was helpful ... and a good idea to separate the concerns of loading the data so clearly, by posting about the LoaderManager first<br /><br />David</div>
</div>
<div class='comment'>
<div class='author'>dbluck</div>
<div class='content'>
Really helpful for aspiring developers, looking forward to the follow-up, Thanks</div>
</div>
<div class='comment'>
<div class='author'>Unknown</div>
<div class='content'>
Yeah it did help :-) Decent Android tutorials that go beyond &#39;hello world&#39; and don&#39;t encourage readers to write unmaintainable crap are few and far between. Thanks!</div>
</div>
</div>
