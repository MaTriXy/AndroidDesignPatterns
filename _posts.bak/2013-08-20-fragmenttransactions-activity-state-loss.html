---
layout: post
title: FragmentTransactions & Activity State Loss
date: 2013-08-20
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>The following stack trace and exception message has plagued StackOverflow ever since Honeycomb's initial release: </p> <p><pre class="brush: plain">java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState<br />    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)<br />    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)<br />    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)<br />    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)<br /></pre></p> <p>This post will explain <i>why</i> and <i>when</i> this exception is thrown, and will conclude with several suggestions that will help ensure it never crashes your application again. </p> <h4>Why was the exception thrown? </h4> <p>The exception was thrown because you attempted to commit a <code>FragmentTransaction</code> after the activity's state had been saved, resulting in a phenomenon known as <i>Activity state loss</i>. Before we get into the details of what this actually means, however, let's first take a look at what happens under-the-hood when <code>onSaveInstanceState()</code> is called. As I discussed in my last post about <a href="http://www.androiddesignpatterns.com/2013/08/binders-death-recipients.html"><code>Binder</code>'s &amp; Death Recipients</a>, Android applications have very little control over their destiny within the Android runtime environment. The Android system has the power to terminate processes at any time to free up memory, and background activities may be killed with little to no warning as a result. To ensure that this sometimes erratic behavior remains hidden from the user, the framework gives each Activity a chance to save its state by calling its <code>onSaveInstanceState()</code> method before making the Activity vulnerable to destruction. When the saved state is later restored, the user will be given the perception that they are seamlessly switching between foreground and background activities, regardless of whether or not the Activity had been killed by the system. </p> <p>When the framework calls <code>onSaveInstanceState()</code>, it passes the method a <code>Bundle</code> object for the Activity to use to save its state, and the Activity records in it the state of its dialogs, fragments, and views. When the method returns, the system parcels the <code>Bundle</code> object across a Binder interface to the System Server process, where it is safely stored away. When the system later decides to recreate the Activity, it sends this same <code>Bundle</code> object back to the application, for it to use to restore the Activity's old state. </p> <p>So why then is the exception thrown? Well, the problem stems from the fact that these <code>Bundle</code> objects represent a snapshot of an Activity at the moment <code>onSaveInstanceState()</code> was called, and nothing more. That means when you call <code>FragmentTransaction#commit()</code> after <code>onSaveInstanceState()</code> is called, the transaction won't be remembered because it was never recorded as part of the Activity's state in the first place. From the user's point of view, the transaction will appear to be lost, resulting in accidental UI state loss. In order to protect the user experience, Android avoids state loss at all costs, and simply throws an <code>IllegalStateException</code> whenever it occurs. </p> <a name='more'></a> <h4>When is the exception thrown? </h4> <p>If you've encountered this exception before, you've probably noticed that the moment when it is thrown is slightly inconsistent across different platform versions. For example, you probably found that older devices tended to throw the exception less frequently, or that your application was more likely to crash when using the support library than when using the official framework classes. These slight inconsistencies have led many to assume that the support library is buggy and can't be trusted. These assumptions, however, are generally not true. </p> <p>The reason why these slight inconsistencies exist stems from a significant change to the Activity lifecycle that was made in Honeycomb. Prior to Honeycomb, Activities were not considered killable until after they had been paused, meaning that <code>onSaveInstanceState()</code> was called immediately before <code>onPause()</code>. Beginning with Honeycomb, however, Activities are considered to be killable only after they have been <i>stopped</i>, meaning that <code>onSaveInstanceState()</code> will now be called before <code>onStop()</code> instead of immediately before <code>onPause()</code>. These differences are summarized in the table below: </p> <table border="1" cellpadding="5">  <tbody><tr>    <th style="width: 270px"></th>    <th>pre-Honeycomb</th>    <th>post-Honeycomb</th>  </tr>  <tr>    <td style="width: 270px">Activities can be killed before <code>onPause()</code>?</td>    <td>NO</td>    <td>NO</td>  </tr>  <tr>    <td style="width: 270px">Activities can be killed before <code>onStop()</code>?</td>    <td>YES</td>    <td>NO</td>  </tr>  <tr>    <td style="width: 270px"><code>onSaveInstanceState(Bundle)</code> is guaranteed to be called before...</td>    <td><code>onPause()</code></td>    <td><code>onStop()</code></td>  </tr></tbody></table> <p>As a result of the slight changes that were made to the Activity lifecycle, the support library sometimes needs to alter its behavior depending on the platform version. For example, on Honeycomb devices and above, an exception will be thrown each and every time a <code>commit()</code> is called after&nbsp;<code>onSaveInstanceState()</code> to warn the developer that state loss has occurred. However, throwing an exception every time this happened would be too restrictive on pre-Honeycomb devices, which have their <code>onSaveInstanceState()</code> method called much earlier in the Activity lifecycle and are more vulnerable to accidental state loss as a result. The Android team was forced to make a compromise: for better inter-operation with older versions of the platform, older devices would have to live with the accidental state loss that might result between <code>onPause()</code> and <code>onStop()</code>. The support library's behavior across the two platforms is summarized in the table below: </p> <table border="1" cellpadding="5">  <tbody><tr>    <th style="width: 270px"></th>    <th>pre-Honeycomb</th>    <th>post-Honeycomb</th>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> before <code>onPause()</code></td>    <td>OK</td>    <td>OK</td>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> between <code>onPause()</code> and <code>onStop()</code></td>    <td>STATE LOSS</td>    <td>OK</td>  </tr>  <tr>    <td style="width: 270px"><code>commit()</code> after <code>onStop()</code></td>    <td>EXCEPTION</td>    <td>EXCEPTION</td>  </tr></tbody></table> <h4>How to avoid the exception? </h4> <p>Avoiding Activity state loss becomes a whole lot easier once you understand what is actually going on. If you've made it this far in the post, hopefully you understand a little better how the support library works and why it is so important to avoid state loss in your applications. In case you've referred to this post in search of a quick fix, however, here are some suggestions to keep in the back of your mind as you work with <code>FragmentTransaction</code>s in your applications: </p> <ul> <li><p><b>Be careful when committing transactions inside Activity lifecycle methods.</b> A large majority of applications will only ever commit transactions the very first time <code>onCreate()</code> is called and/or in response to user input, and will never face any problems as a result. However, as your transactions begin to venture out into the other Activity lifecycle methods, such as <code>onActivityResult()</code>, <code>onStart()</code>, and <code>onResume()</code>, things can get a little tricky. For example, you should not commit transactions inside the <code>FragmentActivity#onResume()</code> method, as there are some cases in which the method can be called before the activity's state has been restored (see the <a href="http://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onResume()">documentation</a> for more information). If your application requires committing a transaction in an Activity lifecycle method other than <code>onCreate()</code>, do it in either <code>FragmentActivity#onResumeFragments()</code> or <code>Activity#onPostResume()</code>. These two methods are guaranteed to be called after the Activity has been restored to its original state, and therefore avoid the possibility of state loss all together. (As an example of how this can be done, check out my answer to <a href="http://stackoverflow.com/q/16265733/844882">this StackOverflow question</a> for some ideas on how to commit <code>FragmentTransaction</code>s in response to calls made to the <code>Activity#onActivityResult()</code> method). </p></li> <li><p><b>Avoid performing transactions inside asynchronous callback methods.</b> This includes commonly used methods such as <code>AsyncTask#onPostExecute()</code> and <code>LoaderManager.LoaderCallbacks#onLoadFinished()</code>. The problem with performing transactions in these methods is that they have no knowledge of the current state of the Activity lifecycle when they are called. For example, consider the following sequence of events: </p> <ol><li value="1">An activity executes an <code>AsyncTask</code>.</li><li value="2">The user presses the "Home" key, causing the activity's <code>onSaveInstanceState()</code> and <code>onStop()</code> methods to be called.</li>  <li value="3">The <code>AsyncTask</code> completes and <code>onPostExecute()</code> is called, unaware that the Activity has since been stopped.</li><li value="4">A <code>FragmentTransaction</code> is committed inside the <code>onPostExecute()</code> method, causing an exception to be thrown.</li></ol> <p>In general, the best way to avoid the exception in these cases is to simply avoid committing transactions in asynchronous callback methods all together. Google engineers seem to agree with this belief as well. According to <a href="https://groups.google.com/d/msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ">this post</a> on the Android Developers group, the Android team considers the major shifts in UI that can result from committing <code>FragmentTransaction</code>s from within asynchronous callback methods to be bad for the user experience. If your application requires performing the transaction inside these callback methods and there is no easy way to guarantee that the callback won't be invoked after <code>onSaveInstanceState()</code>, you may have to resort to using <code>commitAllowingStateLoss()</code> and dealing with the state loss that might occur. (See also these two StackOverflow posts for additional hints, <a href="http://stackoverflow.com/q/8040280/844882">here</a> and <a href="http://stackoverflow.com/q/7992496/844882">here</a>). </p></li> <li><p><b>Use <code>commitAllowingStateLoss()</code> only as a last resort.</b> The only difference between calling <code>commit()</code> and <code>commitAllowingStateLoss()</code> is that the latter will not throw an exception if state loss occurs. Usually you don't want to use this method because it implies that there is a possibility that state loss could happen. The better solution, of course, is to write your application so that <code>commit()</code> is guaranteed to be called before the activity's state has been saved, as this will result in a better user experience. Unless the possibility of state loss can't be avoided, <code>commitAllowingStateLoss()</code> should not be used. </p></li> </ul> <p>Hopefully these tips will help you resolve any issues you have had with this exception in the past. If you are still having trouble, post a question on <a href="http://stackoverflow.com">StackOverflow</a> and post a link in a comment below and I can take a look. :) </p> <p>As always, thanks for reading, and leave a comment if you have any questions. Don't forget to +1 this blog and share this post on Google+ if you found it interesting! </p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Done. :)</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Wow, thank you a lot! I haven&#39;t read them until I see your reply. It seems there is still hope with some work. I think it is very valuable to put these two links in your article :)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Before I get into too many details, have you read these two StackOverflow posts (<a href="http://stackoverflow.com/q/8040280/844882" rel="nofollow">here</a> and <a href="http://stackoverflow.com/q/7992496/844882" rel="nofollow">here</a>)?<br /></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thank you for analyzing the &quot;Avoid performing transactions inside asynchronous callback methods.&quot; senario. Nonetheless, I feel deeply frustrated about the truth. If it is, the blog post &quot;painless threading&quot; (http://android-developers.blogspot.tw/2009/05/painless-threading.html) is useless. <br /><br />The reason why I say so is: <br />1. &quot;onPreExecute(), onPostExecute() and onProgressUpdate() are all invoked on the UI thread&quot;. It is good.<br />2. Showing dialog in these callbacks is pretty reasonable. For example, show a FragmentDiaglog with a progress bar in onPreExecute() and dismiss it in onPostExecute()<br />3. The truth is that if we use these callbacks to show/dismiss FragmentDiaglog, we get &quot;Avoid performing transactions inside asynchronous callback methods.&quot; problem mentioned in this article.<br /><br />It seems there is no solution to the problem.  Is it a Android framework design defect? Screen rotation is troublesome before we can use setRetrainInstance(true) in fragment. Retaining fragment makes rotation easier, but we get stateloss problem. It seems the components in Android cannot work well with each other, i.e. not knowing other components state.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I suppose I would need more information about the specific problem in order to help you out with that. Showing a dialog in response to an action bar item being clicked shouldn&#39;t be any problem.</div>
</div>
<div class='comment'>
<div class='author'>DouO</div>
<div class='content'>
use <b>commit(ft);</b> instead of <b>ft.commit();</b></div>
</div>
<div class='comment'>
<div class='author'>DouO</div>
<div class='content'>
I have <a rel="nofollow" href="https://gist.github.com/douo/7820956">solution</a> for doing commit inside asynchronous callback, I think it better than commitAllowingStateLoss(), If commit happen after activity stopped, we hold the fragment transaction in memory. Restore it and  do commit when activity resume. <br /><br />but commit can be abandon in these situation:<br /><br />1. we discard all fragment transaction after activity has been destroyed<br />2. app has been killed<br /><br />any suggestions?</div>
</div>
<div class='comment'>
<div class='author'>Liorry</div>
<div class='content'>
Thank you for this informative article, however, this exception also occurs when I show a DialogFragment outside of any async task or an Activity lifecycle event. <br />For example, I show my DialogFragment when an ActionBar button is clicked. It works for most users but it crashes for some.<br />I assume I can always wrap the .show() with !isFinishing()... but I don&#39;t know if that&#39;ll help as I can&#39;t reproduce the crash on my devices.<br /><br />I&#39;d appreciate your feedback on that scenario.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
very helpful.. thank u...</div>
</div>
<div class='comment'>
<div class='author'>CrazyHorse</div>
<div class='content'>
Hi Alex, Thank you for the nice article.<br />I just posted a comment/question in your StackOverflow post, addressing this topic. Its re-posted here with more details.<br /><br />Question: I have a dialogfragment that allows a user to (say) send an email. The dialogfragment makes a network call, receives a response and dismisses itself by invoking dismiss() in the response handler. Now if the Home button is pressed before the dialogfragment receives the async response, invoking dismiss() when the async response is actually received will cause a state loss exception, because the fragment is no more. In this scenario, when should dismiss() be invoked so that there is no state loss? Note that request and response are within the dialogfragment, not within the activity, so that this dialogfragment can be re-used else where.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
thanks for the post. very helpful.<br /></div>
</div>
<div class='comment'>
<div class='author'>Roatis Gratian</div>
<div class='content'>
Very nice tutorial!!! Thank you!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Have you considered launching a new Activity instead of adding a new Fragment to the screen? Maybe that would make more sense in these situations where the old UI is essentially replaced entirely by a new UI.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I agree with this comment made by:<br />UnknownAugust 21, 2013 at 2:55 PM<br /><br />Well and what would you do for example with login screen? Let user type nick and password, and after successful log in do what? Show user &quot;You are now logged&quot; and button to go further? It is quite weird, right? In my opinion, in this case you should do major UI move, but you cant inside onLoadFinished .. or is there any better UI solution for this case? <br /><br /><br />So in this situation you should use commitAllowingStateLoss to move to the main app screen? What if the main app screen is already on the backstack and you need to pop the backstack, there doesn&#39;t seem to be a way to pop backstack allowing state loss.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
According to the source code, the fragment manager checks to see if state loss will occur <i>before the commit action is enqueued</i>. So I don&#39;t think using <i>executePendingTransactions()</i> will avoid the possibility of an exception unfortunately (if that&#39;s what you are asking).<br /><br />I can&#39;t think of a situation in which you would specifically want to use <i>executePendingTransactions()</i>, but I&#39;m sure there are at least a few cases... I&#39;ll reply with a comment if I think of anything. Seems like it was included as a public method by the Android team just in case developers ever faced a situation in which they needed to perform the transactions immediately (i.e. synchronously instead of asynchronously). It was probably safer to include it than to force developers into always performing asynchronous transactions no matter what.</div>
</div>
<div class='comment'>
<div class='author'>gunnar kyrre</div>
<div class='content'>
Very helpful article! I have a question though: <br /><br />How helpful do you find the method executePendingTransations and when should it be executed, keeping in mind your post. <br /><br />http://developer.android.com/reference/android/app/FragmentManager.html#executePendingTransactions(). <br /><br />Thanks!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
There shouldn&#39;t be any problem with committing transactions in Activity#onResume(). However, as I explained in the article the support library behaves a little differently, so you shouldn&#39;t commit transactions in FragmentActivity#onResume().</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
...I meant in order to avoid the Exception, not only because of the user experiencie.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Why shouldn&#39;t we use Activity.onResume() for fragments transactions?<br /><br />You&#39;ve already explained the reason to avoid the commit in FragmentActivity.onResume(), but it doesn&#39;t apply on the Activity.<br /><br />Thank you in advanced Alex.<br /><br />Cristian</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Mmmm, I was wrong. onRestoreInstanceState() is called after onStart().<br /><br />Cristian</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I don&#39;t understand why the activity state may not be restored in onStart() yet. This action is supposed to be done in onCreate() or onRestoreInstanceState() which are guaranted to have finished before onStart(), right?<br /><br />I&#39;m very confused about this point.<br /><br />Cristian</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
In case of a AsyncTask nested in a Fragment, it seems to be safe to check for isAdded(), before committing in onPostExecute():<br /><br />class MyFragment extends Fragment {<br />  ...<br />  class MyAsyncTask extends AsyncTask {<br />    ...<br />    @override onPostExecute(...) {<br />      if(!isAdded()) return;<br />      // safe to commit fragment here<br />    }<br />  }<br />}</div>
</div>
<div class='comment'>
<div class='author'>fhucho</div>
<div class='content'>
Thanks, ok, I&#39;ll gladly avoid using handlers and use executePendingTransactions() instead, my only concern was that there must&#39;ve been some reason it&#39;s not being executed immedietely by default.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
(1) I think the proper way to handle transactions in &quot;onActivityResult()&quot; is to delay their execution until &quot;onPostResume()&quot;, as described in my StackOverflow answer <a href="http://stackoverflow.com/questions/16265733/failure-delivering-result-onactivityforresult/18345899#18345899" rel="nofollow">here</a>. &quot;onPostResume()&quot; is guaranteed to be called after &quot;onActivityResult()&quot; and when &quot;onPostResume()&quot; is called the activity&#39;s state should be restored, so it will be safe to perform transactions at this point. It seems like a really weird thing to need to do, but unfortunately it&#39;s necessary because there&#39;s no guarantee that the activity&#39;s state has been restored before then.<br /><br />(2) I&#39;m not 100% about the context of your situation, but as long as the state has been saved it should be fine to call executePendingTransactions() to execute the commit immediately.<br /><br />(3) Using Handlers to solve this problem is something I would try to avoid, whenever possible. Most of the time it will fix the problem (it will delay the commit just enough such that it will happen after the Activity&#39;s state has been restored)... but there really isn&#39;t any guarantee because it all depends on how the Activity/System&#39;s internals are implemented. For example, the support library&#39;s FragmentManager delays resuming its Fragments a bit more than the official framework FragmentManager class, meaning that the activity&#39;s state may get restored a little late depending on the platform. If the activity&#39;s state gets restored late enough such that it happens even after you post a Runnable to the main thread&#39;s message queue, you&#39;ll still get an exception.<br /><br />So basically... I&#39;m not saying you&#39;re not allowed to use Handlers to address these situations... but it is definitely something you need to be very careful about and test thoroughly.</div>
</div>
<div class='comment'>
<div class='author'>Unknown</div>
<div class='content'>
Well and what would you do for example with login screen? Let user type nick and password, and after successful log in do what? Show user &quot;You are now logged&quot; and button to go further? It is quite weird, right? In my opinion, in this case you should do major UI move, but you cant inside onLoadFinished .. or is there any better UI solution for this case? </div>
</div>
<div class='comment'>
<div class='author'>fhucho</div>
<div class='content'>
One way to solve the second and possibly the first problem would be to:<br /><br />1) Send a Runnable to the main thread handler that would create the fragment if it doesn&#39;t exists.<br /><br />2) Send another Runnable that could safely assume that the fragment is created.</div>
</div>
<div class='comment'>
<div class='author'>fhucho</div>
<div class='content'>
Thanks for the blogpost, I ran into this issue just today.<br /><br />I&#39;m writing a small lib called Workers, mostly for personal use, basically a replacement for loaders and async tasks.<br /><br />The Workers lib uses a simple retained fragment whose purpose is to 1) hold references to the workers 2) do some cleanup before activity restart - in Fragment.onDetached().<br /><br />The lib uses a getOrCreateFragment() whenever it needs the fragment. But i ran into two problems:<br /><br />1) If I use the lib in onActivityResult(), for example to load something in the background, the lib may need to create the fragment. Am I correct that it&#39;s ok to use commitAllowingStateLoss() in getOrCreateFragment()?<br /><br />2) getOrCreateFragment() uses FragmentManager.findFragmentByTag() to find out whether the fragment exists. If it doesn&#39;t exist, it adds it and commits. But the problem is that the commit is actually executed later. So if I call getOrCreateFragment() twice, I add two fragments. Is it ok to use FragmentTransaction.executePendingTransactions() to execute the commit immediately?</div>
</div>
<div class='comment'>
<div class='author'>Vladimir Kuts</div>
<div class='content'>
Well, when I was read one of Dianne&#39;s posts, I felt something like the &quot;If framwework have some design limitation, this is your (developer) problem, not the framework&#39;s&quot;. :) Sure, it&#39;s my (and maybe wrong) opinion.<br /><br />I think, there can be some situations, especially on the tablets. They have a lot space on the screen, we can have some fragments shown at the same time. And is it really so incredible situation when one of the fragments has completed loading/refreshing its data (onLoadFinished), and we want to change the adjacent fragment? But we cannot do this because we&#39;ll got the IllegalStateException. That is why I was used postDelayed() - just to use onLoadFinished() event without getting caught in the IllegalStateException trap.<br /><br />On the other hand, there is a logic in what Dianna had said about loaders.<br /><br />My example with auto-switching fragments, this is a requirement of our investor. He WANTS this behavior, and I personally think that it&#39;s useless.<br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
(2) This question is kind of similar to <a href="https://groups.google.com/forum/#!msg/android-developers/dXZZjhRjkMk/QybqCW5ukDwJ" rel="nofollow">the post</a> that I referenced above. Here&#39;s a quote from Dianne Hackborn&#39;s answer:<br /><br /><i>&quot;It&#39;s a bad user experience to show a dialog (or do any other major shift in the UI) as the result of a loader. Here is what you are doing: setting off some operation to run in the background for an in-determinant amount of time, which upon completion may throw something in front of the user yanking them out of whatever they were doing.&quot;</i><br /><br />I would argue that the &quot;auto-switching to the History tab&quot; behavior which you are talking about falls under the &quot;major shift in the UI&quot; category, because it yanks the user out of whatever they are doing after an indeterminate amount of time. The &quot;auto-switching&quot; behavior will likely be janky too, because it won&#39;t happen immediately (it will wait a little bit for the Loader to finish and then will cause a major shift in the UI to shift).<br /><br />In her answer, Dianne also talks about what she believes to be the better alternative:<br /><br /><i>&quot;My suggestion is to show the user whatever information about the loader result in-line in the same way you would show the data from it.&quot;</i><br /><br />In other words, instead of replacing the entire UI with a new fragment, display a message in-line... like &quot;No news is available&quot; or something like that. If you really feel like the auto-switching behavior is right for your app, however, then you might have to resort to using &quot;commitAllowingStateLoss()&quot; (since the LoaderManager can&#39;t know for sure if the Activity has since been stopped when &quot;onLoadFinished()&quot; is called). Given the asynchronous nature of Loaders, there&#39;s really no way around it.<br /><br />Also, in general I would avoid the use of Handlers to address state loss. Posting a message using a Handler only adds a bit more delay before the transaction is eventually executed, which doesn&#39;t guarantee anything about whether the transaction is committed before or after &quot;onSaveInstanceState()&quot; has been called. It&#39;s a bit like attempting to address race conditions using &quot;Thread#sleep()&quot;. It makes it less likely that bad things will happen, but there is no guarantee.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
(1) Sorry, my comment about how it is OK to perform transactions in onCreate() assumes that you are first checking that &quot;savedInstanceState == null&quot;. What I meant to imply was that it&#39;s totally fine to perform transactions in onCreate() the very first time it is called. You&#39;re right that performing the transaction in onCreate() the second time around (when &quot;savedInstanceState != null&quot;) would likely cause problems since the previously saved state hasn&#39;t yet been restored. I&#39;ll clarify this in my post.</div>
</div>
<div class='comment'>
<div class='author'>Vladimir Kuts</div>
<div class='content'>
Thank you for this post! I have two questions, it is possible. <br /><br />The first: it is safe to perform fragment transaction in the onCreate(), but isn&#39;t safe in the onStart(), right? But onCreate() always called before than onStart(). In the onStart() activity state may not be restored - OK. But in this case in the onCreate() activity state also will be not restored. I can&#39;t understand this logic. <br /><br />And the second question. Let&#39;s imagine that we have an activity with two ActionBar tabs and two corresponded fragments that replaces each one. For example, the News and History tabs and fragments. Let&#39;s app always starts with active News tab. But if there is no news, app should auto switch to the History tab. Loaders are used to get data. So, we will know, have we some news or not, only when loader finishes. And there we will get an IllegalStateException, because we can&#39;t perform transaction within Loader callbacks. Do you have any suggestions to avoid an exception? <br /><br />Athis moment of I know two workarounds: commitAllowStateLost() and postDelayed() message. But I will be happy to know another solution. <br /><br />Thanks. </div>
</div>
<div class='comment'>
<div class='author'>Niznash</div>
<div class='content'>
You&#39;ve done it again. Awesome and super helpful.</div>
</div>
<div class='comment'>
<div class='author'>Shannon Lee</div>
<div class='content'>
Mr. Lockwood, this is a well-written article and I thank you for taking the time to explain this phenomenon!</div>
</div>
</div>
