---
layout: post
title: Correctly Managing Your SQLite Database
date: 2012-05-21
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>One thing that I've noticed other Android developers having trouble with is properly setting up their <code>SQLiteDatabase</code>. Often times, I come across questions on StackOverflow asking about error messages such as,</p> <p><pre class="brush: text"><br />E/Database(234): Leak found<br />E/Database(234): Caused by: java.lang.IllegalStateException: SQLiteDatabase created and never closed<br /></pre></p> <p>As you have probably figured out, this exception is thrown when you have opened more <code>SQLiteDatabase</code> instances than you have closed. Managing the database can be complicated when first starting out with Android development, especially to those who are just beginning to understand the <code>Activity</code> lifecycle. The easiest solution is to make your database instance a singleton instance across the entire application's lifecycle. This will ensure that no leaks occur, and will make your life a lot easier since it eliminates the possibility of forgetting to close your database as you code.</p> <p>Here are two examples that illustrates three possible approaches in managing your singleton database. These will ensure safe access to the database throughout the application.</p><a name='more'></a> <h4>Approach #1: Use an Abstract Factory to Instantiate the <code>SQLiteOpenHelper</code></h4> <p>Declare your database helper as a static instance variable and use the Abstract Factory pattern to guarantee the singleton property. The sample code below should give you a good idea on how to go about designing the <code>DatabaseHelper</code> class correctly.</p> <p>The static factory <code>getInstance()</code> method ensures that only one <code>DatabaseHelper</code> will ever exist at any given time. If the <code>sInstance</code> object has not been initialized, one will be created. If one has already been created then it will simply be returned. <b>You should not initialize your helper object using with <code>new DatabaseHelper(context)</code>!</b>. Instead, always use <code>DatabaseHelper.getInstance(context)</code>, as it guarantees that only one database helper will exist across the entire application's lifecycle.</p> <p><pre class="brush: java"><br />public class DatabaseHelper extends SQLiteOpenHelper { <br /><br />  private static DatabaseHelper sInstance = null;<br /><br />  private static final String DATABASE_NAME = "database_name";<br />  private static final String DATABASE_TABLE = "table_name";<br />  private static final int DATABASE_VERSION = 1;<br /><br />  public static DatabaseHelper getInstance(Context context) {<br />     <br />    // Use the application context, which will ensure that you <br />    // don't accidentally leak an Activity's context.<br />    // See this article for more information: http://bit.ly/6LRzfx<br />    if (sInstance == null) {<br />      sInstance = new DatabaseHelper(context.getApplicationContext());<br />    }<br />    return sInstance;<br />  }<br />    <br />  /**<br />   * Constructor should be private to prevent direct instantiation.<br />   * make call to static factory method "getInstance()" instead.<br />   */<br />  private DatabaseHelper(Context context) {<br />    super(context, DATABASE_NAME, null, DATABASE_VERSION);<br />  }<br />}<br /></pre></p> <h4>Approach #2: Wrap the <code>SQLiteDatabase</code> in a <code>ContentProvider</code></h4> <p>This is also a nice approach. For one, the new <code>CursorLoader</code> class requires <code>ContentProvider</code>s, so if you want an Activity or Fragment to implement <code>LoaderManager.LoaderCallbacks&lt;Cursor&gt;</code> with a <code>CursorLoader</code> (<a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html">read this post for more information</a>), you'll need to implement a <code>ContentProvider</code> for your application. Further, you don't need to worry about making a singleton database helper with <code>ContentProvider</code>s. Simply call <code>getContentResolver()</code> from the Activity and the system will take care of everything for you (in other words, there is no need for designing a Singleton pattern to prevent multiple instances from being created).</p> <p>Leave a comment if this helped or if you have any questions! :)</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Keerthi</div>
<div class='content'>
Yes, closing the cursor is mandatory and you can do it by - mCursor.close();</div>
</div>
<div class='comment'>
<div class='author'>Igor Ganapolsky</div>
<div class='content'>
~&quot;you should always call database.close()&quot;<br />I thought you said it isn&#39;t necessary to manually close the database, since the Android runtime will shut it down for you when you close the app?</div>
</div>
<div class='comment'>
<div class='author'>Gary</div>
<div class='content'>
Thanks for your reply Alex. Yes, I had created a subclass of CursorLoader with a SQLite db query in the loadInBackground() method. I realize now that I should have extended the AsyncTaskLoader class instead of CursorLoader for this. That said though, using CursorLoader with a ContentProvider makes more sense - it might take a bit more effort to set up but will probably be a quicker solution in the long run - I&#39;ll be going with that approach. Thanks again. </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I assume by &quot;I&#39;ve set up a very simple CursorLoader&quot; you mean that you created a subclass of CursorLoader and overrided the loadInBackground() method? I guess that would work in the sense that it will allow you to query data from your database rather than a ContentProvider... but that doesn&#39;t change the fact that the CursorLoader class was explicitly designed to be used with the ContentResolver/ContentProvider (the documentation for CursorLoader clearly states this). Extending behavior using inheritance is generally considered fragile from an object oriented programming design perspective (since any changes made to the CursorLoader in the future could potentially break your code). It would be better to use the <a href="https://github.com/commonsguy/cwac-loaderex" rel="nofollow">LoaderEx</a> library that I mentioned above.</div>
</div>
<div class='comment'>
<div class='author'>Gary</div>
<div class='content'>
Hi Alex, <br /><br />Thanks for the posts - all have been very useful!<br /><br />I&#39;m a bit confused when you say that the CursorLoader class requires a ContentProvider. I&#39;ve set up a (very simple) CursorLoader that runs a <br />query directly in the loadInBackground() method e.g.<br /><br /> public Cursor loadInBackground() {<br />  mData = db.query(&quot;myTable&quot;, dataColumns, null, null, null, null, null, null);<br />  return mData;<br /> }<br /><br />1) Is this wrong and I should always use a CP with CursorLoader?<br /><br />2) If the above is a valid way to use a CursorLoader, are there any pitfalls to using this approach?<br /><br />Thanks in advance.<br />Gary.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yes that will be fine (and I recommend looking at the <a href="https://code.google.com/p/iosched/" rel="nofollow">Google I/O 2013 source code</a> for more information on how this can be implemented, as it is a good resource to look at to make sure you are doing things the Android-recommended way).</div>
</div>
<div class='comment'>
<div class='author'>Rajesh Bhat</div>
<div class='content'>
nice one....</div>
</div>
<div class='comment'>
<div class='author'>Jun Zhang</div>
<div class='content'>
This is for approach #2</div>
</div>
<div class='comment'>
<div class='author'>Jun Zhang</div>
<div class='content'>
Forgot to ask do I only need to add mDBHelper = CustomSQLiteHelper.getInstance(getContext()); into CustomContentProvider&#39;s onCreate() func? Thank you in advance.</div>
</div>
<div class='comment'>
<div class='author'>Jun Zhang</div>
<div class='content'>
Hi Alex, <br />Approach 1: If I leave db not closed, I keep getting error log in ecllipse&#39;s logcat, saying db is not closed, although my app is still running. Probably I need to migrate to approach 2. </div>
</div>
<div class='comment'>
<div class='author'>venki.b</div>
<div class='content'>
Thanks for quick reply,<br />    I am closing cursor.close() and database.close() both,before and after closing them i am printing(sysout) the objects of cursor and database.But no change in objects. Here my question is what exactly close() method do on both. <br /><br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
cursor.close() and database.close() are separate. You should always remember to close your Cursors when you are done using them. Likewise, you should always call database.close() when you are done with the connection to the database.</div>
</div>
<div class='comment'>
<div class='author'>venki.b</div>
<div class='content'>
Hi Alex Lockwood,<br /><br /> I have Doubt regarding database.close() and cursor.close().If i call database.close() will it close all cursor which are associated with it &#39;or&#39; should i call cursor.close() for each cursor before database.close() call ? why ?.Please can you explain me. <br /><br />Thanks   </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Thanks! I&#39;ll fix that in a sec.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thanks for the post, helped me a lot!<br /><br />A minor, minor thing i thought of: the instance variable should probably be called sInstance according to the android code standard =)(since it&#39;s static)</div>
</div>
<div class='comment'>
<div class='author'>Mark Wigzell</div>
<div class='content'>
My concern here relates to being able to inject a mock of the content provider, in order to do unit testing as opposed to say &quot;integrated testing&quot; where the content provider would be wanted. In the case of an isolated unit test we don&#39;t want the singleton content provider. But if the code simply accesses it (instantiating if necessary), then we can&#39;t get it out of the unit test. (Dependency injection is the issue!)<br /><br />The other concern with singletons is that the initialization sequence can&#39;t be easily determined (or relied on). For instance, if you want to do some kind of a reset in your running code, a complete tear-down of everything, and a re-init of everything. Then the singletons become bothersome, because as the code grows, the dependency graph of the singleton is out of sight (its just grabbed from wherever), thus it becomes difficult to control.<br /><br />Yes, I think the content provider pattern is preferable in view of my concerns listed above: &quot;dependency injection&quot; and &quot;deterministic tear-down and init&quot;.<br /><br />Btw. Great blog, thanks!<br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I&#39;ve done unit tests with ContentProviders before and had no problems with using a singleton (I believe there is a class in the testing framework that abstracts most of the boiler plate code for you). I&#39;m not sure about whether or not using a singleton in this way will cause any problems with unit testing a SQLite database, but if it does then you could simply create/open the connection in setUp(), remembering to close it in tearDown(). If you were to use a singleton here, I don&#39;t think you will need to make any huge changes in order to testing your code.</div>
</div>
<div class='comment'>
<div class='author'>Mark Wigzell</div>
<div class='content'>
Alex, whenever I see singleton&#39;s being recomended I get a little jumpy, since they usually spell trouble later on. For instance running unit tests which end up starting the application once per unit test, leaving a host of unclosed databases behind? Similarly, still on the testing bandwagon, having code grab a singleton out of the blue causes deterministic  init sequences to fail, since you never know where or what the singleton is going to grab when invoked. it also means it becomes hard to stub out such. Possibly using ContentProvider pattern will allay these fears. Thoughts?<br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
You don&#39;t need to develop one in order to use a Loader... but you do need to use one if you want to use a CursorLoader. If you choose not to implement a ContentProvider, you can use the SQLiteLoader provided in the LoaderEx library (linked above).<br /><br />It isn&#39;t bad practice and there is no resource overkill. The only downside is that it is a little more tedious to write because it requires more code (in my opinion it is not a big deal though, especially after you get used to writing them). The upside of writing the extra code is that you get to use the CursorLoader. If you ever decide to make use of certain features which require a ContentProvider at some point in the future, you will be happy that you already have one implemented too. :)<br /><br />And lastly, don&#39;t trust any documentation that uses managedQuery() because it is outdated and is probably not something that you should readily trust.</div>
</div>
<div class='comment'>
<div class='author'>Philipp</div>
<div class='content'>
Hi Alex,<br />a follow-up to David&#39;s question: <br />I&#39;m fairly new to android development and after looking at some examples and your blog entries on how to best implement sqlite into my application, I was going to use a ContentProvider with Loader&#39;s, too. But there is this quote, &quot;You don&#39;t NEED to develop your own cp if you don&#39;t intend to share...&quot;. So...<br />Does this mean it is bad practice, resource overkill, something else to use a CP in that case? Because to me it seems the easiest way (specially with all the examples online -- and the official samples still using the deprecated managedQuery() call )<br />Thanks!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yes, one of the drawbacks of not using a ContentProvider is that you don&#39;t get to use a CursorLoader. The docs that state &quot;you don&#39;t need to develop your own provider if you don&#39;t intend to share data with other applications&quot; are correct, but they don&#39;t address this issue.<br /><br />There is a very nice Loader library called <a href="https://github.com/commonsguy/cwac-loaderex" rel="nofollow">LoaderEx</a> that allows you to load data directly from an SQLiteDatabase without using a ContentProvider. You should check it out!</div>
</div>
<div class='comment'>
<div class='author'>David COHEN</div>
<div class='content'>
Hi Alex,<br /><br />Thanks for all of that : articles, comments &amp; replies. It was so helpfull. <br />I introduced Loaders in my application thanks to you. <br />But in my case ContentProvider didn&#39;t seem to be the best way... According to the documentation : &quot;You don&#39;t need to develop your own provider if you don&#39;t intend to share your data with other applications&quot;<br />http://developer.android.com/guide/topics/providers/content-providers.html<br /><br />So in my case I chose to use a singleton and my cursorLoader is updated by a localBroadcastReceiver (my service in charge of update from net send the intent after any db update). Is it a good practice ?</div>
</div>
<div class='comment'>
<div class='author'>Marco Marangoni</div>
<div class='content'>
I use the first connection pattern, but randomly I get an exceptioN.<br />The connection pool for database &#39;/data/data/xyx/xyz.db&#39; has been unable to grant a connection to thread xyz with flags 0x1 for 270 seconds<br /><br />Do you know why?<br /><br />PS: I use the same database connection in many threads and services (app, widgets, auto-update services ecc..)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yup!</div>
</div>
<div class='comment'>
<div class='author'>haibison</div>
<div class='content'>
Hi Alex,<br /><br />I&#39;m opening a file in my content provider. From what you explained, I think I don&#39;t need to close it. Am I right?<br /><br />Thank you in advance.<br /><br />Sincerely,<br />Hai</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thanks for the very useful article.<br />Could you please write an article on what how to manage a database with multiple tables.</div>
</div>
<div class='comment'>
<div class='author'>Grin</div>
<div class='content'>
Ok, Here is the question: http://stackoverflow.com/questions/14976746/error-cannot-perform-this-operation-because-the-connection-pool-has-been-closed<br />Thanks for your answer! :)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
It&#39;s better to post the question on StackOverflow. You can link me to the post if you want here. :)<br /></div>
</div>
<div class='comment'>
<div class='author'>Grin</div>
<div class='content'>
Hi Alex. Thank you for your code! It work very well but sometimes i get the error &quot;java.lang.IllegalStateException: Cannot perform this operation because the connection pool has been closed.&quot;. <br />Here is the link: https://dl.dropbox.com/u/105753409/Snapshot_2013-02-20_140901.png.<br />Can you help me to fix it? Thank you so much! :)</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Thanks Alex.  I removed the synchronization and it appears to work for now.  The non standard part is that I want to nest the inserts via the content provider within another transaction, for speed.  I created a static method within the content provider class to support this, which just begins the transaction, and returns the database.  I then end the transaction/set it successful outside of the provider.  <br /><br />Somehow without this method synchronized with the others, I was getting an error from SQLiteConnectionPool about being unable to grant a connection due to an idle connection. Obviously, there should only be one connection at a time, so I thought it was a problem with threads. <br /><br />However, once I removed the synchronization on the standard Content Provider methods, as you suggested, the problem seemed to go away.   Now I think the problem was likely caused by using synchronized methods on top of the synchronized SQLiteDatabase, which ended up creating a deadlock of some kind. </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I would do it the way Pro Android 4 says to. Getting the writeable database in each ContentProvider method isn&#39;t bad design... this is how the developer site suggests you do it.<br /><br />You definitely shouldn&#39;t have to synchronize all of the CP methods in order to avoid opening multiple connections to the DB. Your ContentProvider should hold a single database connection (an instance of SQLiteDatabase), which it will initialize only once in ContentProvider#onCreate(). The SQLiteDatabase itself is thread safe internally, so calling the ContentProvider methods from multiple threads shouldn&#39;t result in any race conditions. <br /><br />Read more about this here: http://www.androiddesignpatterns.com/2012/10/sqlite-contentprovider-thread-safety.html</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hmm, somehow I ended up implementing both methods #1 and #2. When inserting, updating, deleting, etc., my Content Provider calls the database helper and gets the writeable database.  Are you saying that this is unnecessary or poor design?  There could just be a SQLiteDatabase in the Provider? <br /><br />I followed the guidelines from Pro Android 4. (see the Creating a Content Provider Section) <br />http://www.satyakomatineni.com/akc/display?url=DisplayNoteIMPURL&amp;reportId=2882&amp;ownerUserId=satya<br /><br />One problem I ran into was that I had to synchronize all of the Content Provider methods in order to avoid opening multiple connections to the DB. </div>
</div>
<div class='comment'>
<div class='author'>Rachit</div>
<div class='content'>
Thanks a lot for your help!!!!!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Sorry for the late response. I&#39;ve read a while ago the exact reason why it was OK to keep the connection open, but couldn&#39;t remember where I had seen it. Anyway, I finally found it online today! Check out this <a href="http://touchlabblog.tumblr.com/post/24474750219/single-sqlite-connection" rel="nofollow">blog post</a> </div>
</div>
<div class='comment'>
<div class='author'>Rachit</div>
<div class='content'>
Hi Alex, <br /><br />Thanks for the reply. <br /><br />Just to confirm keeping the DB open means 1. Keeping a single instance of the DBHelper in memory at all times as well as 2. keeping the writableDatabase reference also without closing it? I noticed that a journal file is created for the DB. If my process gets killed then will the changes in the journal be updated in the DB?<br /><br />How expensive is getting a writableDatabase reference each time before querying?<br /><br />Thanks a lot for your time and help.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hey Rachit, sorry about getting back to you so late.<br /><br />You could use either, but I would prefer the ApplicationContext (that way you know for sure that you will never accidentally leak a Context). It&#39;s also fine to keep the Database open, as it isn&#39;t expensive to do so. You should make sure that you don&#39;t accidentally open more than one SQLiteDatabase instances though, as this will most likely result in an exception being thrown.</div>
</div>
<div class='comment'>
<div class='author'>Rachit Agarwal</div>
<div class='content'>
Hi Alex,<br /><br />Regarding Robert&#39;s query about a service, I am trying to do the same thing. I have a service which is periodically, say every 15 mins, checking for and inserting data to the SQLite Database and a main application which may or may not be frequently opened. With the singleton approach, should I be creating the instance with the ApplicationContext or the MAIN LAUNCHER activity context? Because from Honeycomb onwards, service is started only after the Launcher activity is first started.<br /><br />Also, in this case is it ok, for the DB connection to be always open? I will not be closing the connection in either the service or the application because the other one maybe using it at the same time.<br /><br />Thanks for your help.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
I have been trawling the web for a proper way to handle an SQL database for use through multiple activities. All I was finding was some messy method where you create a &quot;global&quot; database via extension of the Application class. This is a much neater and maintainable solution. Thanks!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
No, you shouldn&#39;t have to do that. And actually, the two approaches are pretty much the same things in the sense that they (1) both instantiate an SQLiteOpenHelper when the application is first started and (2) both are cleaned up when the process is killed (as opposed to being closed directly). Does that make sense?</div>
</div>
<div class='comment'>
<div class='author'>wcw</div>
<div class='content'>
From above I already know using ContentProvider needn&#39;t care about closing the db. So how about approach #1? Do i need to close db in each Activity&#39;s onDestroy()?</div>
</div>
<div class='comment'>
<div class='author'>Danielle Rosario</div>
<div class='content'>
Good remedy you offered here with example of SQLite data source with android operating system applications.generally fresh of Android applications discover this mistake and could not fix by self.by your publish they can fix this issue.</div>
</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>
Thanks for the clarifications.<br />I will try it (at the moment I am working on something else) and let you know about the results.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
The service that applies the batch insert shouldn&#39;t take as long as you think. Most of the work will be the retrieval/processing of the raw data that the Service receives (i.e. setting up a list of ContentProviderOperations to pass to the applyBatch() method). The only time that the SQLiteDatabase will hold a lock on the database is from the time that you call &quot;applyBatch&quot; to the time that the call finishes. The &quot;applyBatch()&quot; method will perform a lightning-fast SQLite transaction, so even if you ran into a scenario in which the CursorLoader needed to perform a new query <i>exactly</i> as new data was being inserted from the Service, the SQLiteDatabase will block for an incredibly short amount of time (the user most likely won&#39;t even notice).<br /><br />Also, creating a new connection to the database wouldn&#39;t offer any alternative solution. The SQLiteDatabase will throw a &quot;DatabaseLockedException&quot; (or something like that... not sure about the exact exception name :P) exception if two connections attempt to modify the same database instance simultaneously from multiple threads. In other words, even if you created a second connection, Android wouldn&#39;t allow you to perform multiple SQLite operations on the database at once. In all honesty, I think this was a good design decision because (1) you are working with a mobile device with limited memory and pretty much no swap space, so SQLite operations shouldn&#39;t take that long to begin with, and (2) developers are pretty much guaranteed that their SQLiteDatabase will <i>never</i> be accidentally corrupted due to race conditions.</div>
</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>
Thanks for the quick reply.<br />Actually I am using CursorLoader. My concern is of a different matter, even if I did not tested it yet, according to the documentation and your post, there will be only ONE thread at a time that can access the db.<br />Now suppose the user is on a form with data loaded. The background sync kicks in and fetches a lot of records and then calls applyBatch() - this probably will take a while. If in this time the user goes to another form which loads data from the db (using CursorLoader) ... then he will end up with ... <br />- an empty form / list ?<br />- a notice that the data is being updated and he should wait or come back later ?<br />- another suggestion ?<br /><br />In a desktop app, using a second connection it will show up with the current data.<br /><br />I hope that I was clear enough in explaining the scenario and thank you for your time.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Use a CursorLoader to query the data from the database (I&#39;ve written a number of posts on this as well... check out my posts on Loaders!). The CursorLoader performs queries (on a separate thread, so it won&#39;t block the UI from being generated) and registers a ContentObserver such that it will be notified automatically when the CP changes. Assuming you call &quot;ContentResolver#notifyChange(Uri, null)&quot; in your insert/delete/update methods, and &quot;Cursor#setNotificationUri(Uri)&quot; in query, the CursorLoader will be notified of any operations being performed on the CP and will requery its data automatically.<br /><br />I&#39;m not sure what your approach is right now, but Cursorloader is 110% the way to go. I&#39;m serious! If you are not using a CursorLoader in your app, then do whatever you can to change things around so that you use it! <br /><br />Hope that makes sense. :)</div>
</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>
Hi Alex,<br /><br />Thanks for the suggestion. I will test the approach. My only concern is related to the impact of a large batch of updates on the data that should be displayed in the UI, in case the user is interacting with the app in the meantime.<br /><br />Regards,<br />Robert</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hi Robert,<br /><br />Using a single SQLiteDatabase connection is totally fine in your case. Just call the DB&#39;s methods (or ContentResolver&#39;s methods, if you are using a CP) directly from inside your service. There won&#39;t be any weird conflicts between your Activity and Service because SQLiteDatabase is thread safe (see my latest <a href="http://www.androiddesignpatterns.com/2012/10/sqlite-contentprovider-thread-safety.html" rel="nofollow">post</a> for more information about this). You don&#39;t need to &quot;serialize&quot; the activity&#39;s behavior because the SQLiteDatabase eliminates any potential race conditions for you.<br /><br />The Google I/O 2012 application implements this pattern too, by the way. If you check out the source code, you&#39;ll see that the ContentProvider holds a reference to only one DB connection (see the <a href="http://code.google.com/p/iosched/source/browse/#git%2Fandroid%2Fsrc%2Fcom%2Fgoogle%2Fandroid%2Fapps%2Fiosched%2Fprovider" rel="nofollow">provider</a> package) and a service (see the <a href="http://code.google.com/p/iosched/source/browse/#git%2Fandroid%2Fsrc%2Fcom%2Fgoogle%2Fandroid%2Fapps%2Fiosched%2Fsync" rel="nofollow">sync</a> package) runs in the background, calling &quot;ContentResolver.applyBatch()&quot; when data is received from the server. There are no conflicts between the Activity and Service because the SQLiteDatabase serializes access to the data... only one thread is allowed to have access to it at a time, so there won&#39;t be any race conditions/deadlocks/whatever.<br /><br />Hope that answers your question! :)<br />Alex</div>
</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>
Hi Alex,<br /><br />My problem is related to not being able to have TWO separate connections to the same SQLite database in an Android app (or at least I did not found a way to do this until now).<br /><br />The scenario I am trying to implement is the following:<br />- Having a UI with lists, and other forms bound to table fields, using ContentProvider (or Local DB as a singleton), where there can be all kind of interactions with the DB (mainly selects - using async calls, but also inserts, updates, deletes!!!)<br />- Having a service that updates regularly the data in the database, using ... and here is my problem. What should I use here?<br /><br />The service should be able to update the database inside a TRANSACTION, isolated from the UI, until it is committed. In a normal desktop application this can be achieved by using two different connections to the DB.<br /><br />So is there a way of achieving the same functionality in an Android application or I am stuck with &quot;serializing&quot; the activities (so that when the service has to update the DB only SELECTS would be permitted for the UI)?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hi Jason,<br /><br />You shouldn&#39;t need to worry about Database Locked Exceptions when working with a ContentProvider... if you take a look at the source code for <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/database/sqlite/SQLiteDatabase.java" rel="nofollow">SQLiteDatabase</a> you&#39;ll find that access to the underlying database is already synchronized. Assuming your ContentProvider only instantiates one SQLiteDatabase (or SQLiteOpenHelper), you shouldn&#39;t run into any &quot;database locked&quot; exceptions.<br /><br />As for performing separate queries within the Activity, you could use an <a href="http://developer.android.com/reference/android/content/AsyncQueryHandler.html" rel="nofollow">AsyncQueryHandler</a>, which is a helper class to help make handling asynchronous ContentResolver queries easier. I would avoid using &quot;getContentResolver().query()&quot; on the main UI thread as querying a database is a potentially expensive operation and can thus introduce lag.</div>
</div>
<div class='comment'>
<div class='author'>Jason</div>
<div class='content'>
Alex,<br /><br />If I am using a ContentProvider (accessing a Sqlite db) with a CursorLoader to populate a ListView but then I need to make another separate query to the database within the same Activity, what it the best way to go about this?<br /><br />Would you use getContentResolver() from the activity to return a new Cursor and then close it yourself? If so, would this be in a different thread and could there be any issues with Database Locked Exceptions?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
1) Again, the SQLiteOpenHelper definitely DOES depend on the Context, as without it it would have no way of knowing where the SQLiteDatabase exists on the disk. So your statement that &quot;it makes no logical sense for a database to depend on a Context&quot; is incorrect. The logic behind it is that the SQLiteOpenHelper needs to retrieve the application&#39;s information in order to know where to initialize the database on the disk. Therefore the SQLiteOpenHelper must depend on the application context.<br /><br />2) Application extends Context so there is no point in holding a reference to a Context in your subclass of Application.<br /><br />3) The DatabaseHelper&#39;s implementation will never have to change... so I&#39;m not sure why you are worried about having to &quot;maintain it in the future&quot;. The Context is the central core of how Android applications work... its not going anywhere anytime soon.<br /><br />4) From the documentation on the <a href="http://developer.android.com/reference/android/app/Application.html" rel="nofollow">Application</a> class:<br /><br />&quot;There is normally no need to subclass Application. In most situation, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), the function to retrieve it can be given a Context which internally uses Context.getApplicationContext() when first constructing the singleton.&quot;<br /><br />Therefore, it is clear that the people who wrote the Android framework don&#39;t approve of subclassing Application simply to retrieve the application&#39;s context... instead they recommend passing a Context as an argument to the method.<br /><br />5) All that said, I&#39;m still confused as to how you would retrieve the Context from within the DatabaseHelper if you aren&#39;t given a Context as an argument to the method... how do you plan on doing this?</div>
</div>
<div class='comment'>
<div class='author'>Gothri</div>
<div class='content'>
Alex, for SQLite I believe that the whole problem with the Context is that the Context lacks context.  Allow me to explain.<br /><br />It makes sense to pass a Context to things like UI display elements such as widgets or ListAdapters because there is a logical dependency of widgets to classes that operate on the user interface and, hence, rely on Context.<br /><br />In contrast, it makes no logical sense for a database to depend on a Context (and in reality it doesn&#39;t ... if their were another elegant way for the app to learn where to put the database, then there would be no dependency on the Context at all).  For this reason, passing a Context to the abstract Factory method becomes part of the database implementation rather than a natural dependency.<br /><br />If one uses a database adapter class to abstract the database implementation, it makes sense to wrap all the implementation-dependent features into the adapter.  Upgrading or changing the adapter could potentially mean upgrading every other class in the project where method signatures appear that contained Context as an argument.  This makes the code less simple and less easy to maintain.<br /><br />Taking the Context out of the method signatures and wrapping it into a global application state therefore preserves the abstraction of the adapter class since the the adapter is the only class that needs to work with the Application object.  It&#39;s a matter of style, but I contend that this keeps the project simpler and easier to maintain.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
@Gothri<br /><br />1) You are correct in that the <i>SQLiteOpenHelper</i> needs the <i>Context</i> to know where to store the SQLite database on the disk. <br /><br />2) How is subclassing Application any better? In my opinion passing the Context as a parameter to an argument is WAY cleaner/simpler than subclassing Application, don&#39;t you agree? If I understand correctly, you are trading a bunch of unnecessary code in your manifest and a new .java file for the ability to write <i>DatabaseHelper.getInstance()</i> instead of <i>DatabaseHelper.getInstance(this)</i>?<br /><br />The whole purpose of the Context is to provide application-specific resources to classes/objects that don&#39;t have direct access to them, so quite frankly the Context is <i>meant</i> to be passed around like this. Go for it if you want, but I still think that there is absolutely nothing wrong with passing the Context as a parameter to the method.<br /><br />Browse through the <a href="http://code.google.com/p/iosched/source/browse/android/src/com/google/android/apps/iosched/util/?r=fcd13b09ef50f290dc0681ebec74fbdfcac969a5" rel="nofollow">util</a> package in the Google I/O 2012 source code and you&#39;ll find that most static utility methods take Contexts as arguments... so I definitely wouldn&#39;t call this bad practice!</div>
</div>
<div class='comment'>
<div class='author'>Gothri</div>
<div class='content'>
Alex, you&#39;re right, it doesn&#39;t seem that bad.  But here are my beefs:<br /><br />1) opening or otherwise using a database is not -related- to the Context.  You shouldn&#39;t -need- a Context to access or use a database because the Context does not have any kind of close relationship to the database.<br /><br />I mean, I think I know why SQLiteOpenHelper wants a Context.  I think it is because SQLiteOpenHelper wants to know where on the device to create the database file.  Aside from that, there&#39;s no reason for SQLite to have a Context.<br /><br />2) The Context isn&#39;t even used by the class containing the Factory method.  The Context is used only when the singleton is created, but for all other uses of getInstance, the Context is passed but never needed or used.<br /><br />3) If you write an ordinary Java class (i.e. a class outside the Android lifecycle paradigm or subclassed from the SDK) and you want to access an SQLite database, you&#39;re screwed ... unless you pass a Context which the Java class does not need for anything except finding the database.<br /><br />That is what bothers me about passing a Context to the Factory method: it isn&#39;t needed, it&#39;s only used once, and it&#39;s burdensome.  I do not understand why Context.getApplicationContext() is not implemented as a static method so that you could at least get the application context without an instance of some Context class or subclass.<br /><br />It makes me want to extend the Application class just so that I can have the application context on hand somewhere if I need it:<br /><br />-----<br /><br />&quot;Many of us want to write some logic outside activity class. But we are stopped from doing this by many reasons, of which one is accessing application context to interact with database. Context is available to us in activity but not in plain java class.<br /><br />By following the below steps you may access application context statically across your android application :&quot;<br /><br />1. Modify the android manifest by providing a class (android:name) to application tag<br /><br />2. Then write the class<br /><br />    public class CustomApplication extends Application{<br />     private static Context context;<br />     public void onCreate(){<br />       context=getApplicationContext();<br />     }<br /><br />     public static Context getCustomAppContext(){<br />       return context;<br />     } <br />   }</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
@Gothri<br /><br />You are correct... I didn&#39;t actually need to hold a reference to the context as a class field. I just removed the &quot;private Context mCtx&quot; field from the sample code... thanks for the catch!<br /><br />You are, however, required to pass the <i>Context</i> as an argument to the static factory method. Without passing a Context as an argument to the method, the <i>DatabaseHelper</i> would have no way of instantiating itself. The same concept applies with adapters, views, and every other class that has its public constructor take a Context as an argument.<br /><br />tl;dr - The <i>SQLiteOpenHelper</i> cannot acquire a context by itself... it must be passed a Context as a parameter in order to be instantiated.<br /><br />But come on, man... it&#39;s just one argument... it&#39;s not that bad! :P </div>
</div>
<div class='comment'>
<div class='author'>Gothri</div>
<div class='content'>
Alex, why is your sample code hanging onto a reference to a supplied context as a private field in DatabaseHelper?  Your example code makes no use of this object reference aside from its initial assignment.<br /><br />I am wrestling with this idea of using SQLite with a &quot;global application scope&quot;.  I want to use a singleton, but this whole problem of SQLiteOpenHelper needing a Context really bugs me.  I do not -want- to pass a Context to my GetInstance() method (or any other argument, for that matter;  I just want to, you know, get the instance).<br /><br />My question is this: is there some cleaner way to generate a Context for SQLiteOpenHelper that does not involve passing a Context reference to the factory method but which still allows trouble-free access to the same SQLite database across all the activities the app may happen to have?  This has really been bothering me :-\</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hi Louis,<br /><br />There really is no harm in leaving the database open. SQLite itself promises that the database won’t be corrupted if the process goes down suddenly, even in the middle of an update. This means that the only other real need for closing the database is to ensure that in-process resources (locks, memory buffers, etc.) are cleaned up appropriately — none of which will really matter because the Android system will kill the entire process when the application closes.<br /><br />Hope that makes sense!<br />Alex</div>
</div>
<div class='comment'>
<div class='author'>Louis</div>
<div class='content'>
Hi Alex,<br /><br />I can&#39;t help but think about the db close() method.<br /><br />Is it really safe to not close the connection and leave it for garbage collection?<br /><br />I think lots of others are confused about this as well...<br /><br />Louis  </div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Thanks for the comment, Rob. You are correct. A couple of notes:<br /><br />If we don&#39;t make the static helper method <i>synchronized</i>, a race condition can only ever occur the very first time <i>getInstance</i> is called (since this is the only time when <i>mInstance</i> is null, and thus, the only time that two or more threads can interleave and accidentally initialize more than one instance). In Android programming, this is incredibly rare, as more often than not, the first call to <i>getInstance</i> is made on the main UI thread before multiple threads are introduced in the application. <br /><br />With that in mind, making the method <i>synchronized</i> is a bit overblown in my opinion. As Rob points out, it will eliminate potential race conditions, but it also means that you will have to pay the cost of synchronization for every invocation of the method, even in situations where synchronization is completely unnecessary.<br /><br />Therefore, the best solution is to avoid calls to <i>getInstance</i> from multiple threads. Instead, consider holding a reference to the <i>DatabaseHelper</i> in the Activity and/or Fragment, and initialize it in <i>onCreate</i> before multiple threads are introduced.<br /><br />Thanks again for pointing that out! :)<br />Alex</div>
</div>
<div class='comment'>
<div class='author'>Rob</div>
<div class='content'>
Hey,<br /><br />just a comment about approach #1, the singleton design pattern. <br />You have not declared the getInstance() method as synchronized, therefore you can not guarantee a singleton approach in a multi threaded application.<br /><br />This is a common mistake when using this pattern.<br />It is either missed out due to forgetfulness or it is missed out because the code inside does some form of lock. Either way the simplest and best approach is a sync lock on the method.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
The ContentProvider is what you use to insert/update/query data from your internal database. It knows nothing about &quot;offline&quot; or &quot;online&quot; data... it is just there to store the data your application needs to store. The Loader provides asynchronous loading of data and monitors the source of the data, delivering new results when the content changes.<br /><br />In both cases (online and offline), the user loads the data that is stored in the ContentProvider. The only difference is that if the user is online, the data will be periodically updated by an external source. When the data is downloaded and inserted/updated (by calling the ContentProvider&#39;s insert/update method), the ContentProvider will recognize that changes have being made and will tell the Loader to update its data. This way you abstract the difference between &quot;offline&quot; and &quot;online&quot; data and make your code a whole lot easier to deal with. Does that make sense? Or did I misunderstand?</div>
</div>
<div class='comment'>
<div class='author'>Michał K</div>
<div class='content'>
There&#39;s one important scenario when this approach wouldn&#39;t work (or am I wrong?). When the user returns to the app without Internet connection and wants to view data he&#39;s previously downloaded (i.e. downloaded from external databse and written to internal).<br /><br />I mean, if a user has Internet connection all the time, everything is great, data is perceived by the Loader as long as the Loader lives. But I want to keep the data between app restarts, access it as quickly as possible and update online whenever possible.<br /><br />So one Loader to provide data from ContentProvider (offline), but what should I use to update the data?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yes, that&#39;s true. I&#39;m actually thinking of removing approach #1 from the blog post all together... I think #2 is a much better approach. In fact, there are some cases where subclassing Application can cause you trouble. There can only be <i>one</i> subclass of Application, which makes it more difficult for you if you need to use other subclasses of Application later on. Using a static data member avoids that. <br /><br />Now about your question... if I recall correctly, the CursorLoader will register a ContentObserver with the dataset you requested and will call <i>forceLoad()</i> on itself when the data set changes, correct? As long as your external source is updating the data via your ContentProvider, and your insert and update methods are calling <i>getContentResolver().notifyChange(...)</i> once the transaction has completed, shouldn&#39;t this be relatively simple? I don&#39;t think there is a need to have two different loaders... I think you just have to make sure your Loader is getting notified when the data set is changed.</div>
</div>
<div class='comment'>
<div class='author'>Michał K</div>
<div class='content'>
Hi Alex,<br /><br />I think it&#39;s worth mentioning, that using the second approach you never need to close the database. It&#39;s obvious for you, I suppose, but wasn&#39;t that obvious for me and caused me some problems when I accessed my db from many places at once (Fragments in ViewPager).<br /><br />And a question: is it possible/easy/hard to implement the third approach to retrieve data from local database with LoaderManager and ContentProvider, but to have this data at the same time updated from an external source? Now, I use an approach with two different Loaders (one offline and one online) and it works, but it seems terribly hackish and the code is ugly. Can you suggest anything?<br /><br />Thanks:)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hi eleanzx, thanks for the comment. You are correct in that <i>onTerminate()</i> is not called on real devices (and if you are only working with real devices, you could probably get away with not including it all together).<br /><br />The reason I overrided the <i>onTerminate</i> method is:<br /><br />(1) According to the documentation, the method may be called in &quot;emulated process environments&quot; (i.e. if you are debugging your application with the emulator), so I included it just to be safe. I&#39;m not 100% sure how process cleanup works on the emulator, but it&#39;s better to be safe than sorry!<br /><br />(2) It makes the code a little easier to understand. If I didn&#39;t include it, it would look like I was opening the database without ever closing it, which goes against the whole purpose of this blog post. I thought it was less confusing this way. :)<br /><br />That being said, of course it isn&#39;t necessary to close the database in <i>onTerminate</i>. The Application instance represents a global process and nothing more. When an Android app is terminated, its processes are removed by simply killing them. The &quot;leak found&quot; error message is given when the garbage collector finds and frees a SQLiteDatabase instance that has not been closed. Therefore, since the process is killed and all of the process&#39; memory resources are removed and freed at this point, there is no reason to close the database. Again, I mostly just included it for clarity. <br /><br />Let me know if that clears things up for you,<br />Alex</div>
</div>
<div class='comment'>
<div class='author'>eleonzx</div>
<div class='content'>
Hi, nice post, I think I&#39;ll be using your first approach, but reading the Android docs: http://developer.android.com/reference/android/app/Application.html#onTerminate()<br /><br />It said this method will never be called on a Real device, ¿Is there some particular reason for calling it that I&#39;m missing?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Glad the post helped you out, Bhagwad! <br /><br />There are definitely <a href="http://www.androiddesignpatterns.com/2012/05/why-you-should-use-loadermanager.html" rel="nofollow">benefits</a> to using ContentProviders though... don&#39;t give up on them too quickly!</div>
</div>
<div class='comment'>
<div class='author'>Bhagwad Jal Park</div>
<div class='content'>
This is a great solution. I was experiencing nightmarish &quot;database locked&quot; scenarios with multiple services accessing the database at the same time and the open and close synchronization was driving me mad.<br /><br />I just implemented your first method, and voila! Everything&#39;s magical. Having just one instance throughout the app is super sexy and makes database management a breeze.<br /><br />With this solution, why would I ever need Content Providers?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Hi Dimath,<br /><br />Good question! <br /><br />(1) When working with ContentProviders, it is perfectly fine to leaving the database connection open throughout the entire runtime of your app. ContentProviders (as well as many of the SQLiteDatabase resources associated with it, such as the database instance itself) are created and managed by the system throughout your app&#39;s lifecycle. In fact, the whole purpose of the ContentProvider is to abstract these details from the developer. I understand your confusion, as the code suggests that the database is opened once and never closed, but the fact of the matter is that doing so is perfectly acceptable. There are tons of tutorials/sample code on the developer&#39;s website that are implemented this way too (if you don&#39;t believe me :P).<br /><br />(2) The same logic does not apply to cursors returned by calls to &quot;query()&quot;. Say you made the following call:<br /><br />Cursor cur = getContentResolver().query(...);<br /><br />The developer should remember to call &quot;cur.close()&quot; on this cursor when finished. Well, most of the time at least... there are a couple exceptions. For instance, if you called &quot;startManagingCursor(cur)&quot; (which is deprecated as of API 11... don&#39;t use it!), you should stop managing cursor with the trivially named &quot;stopManagingCursor(cur)&quot; method instead. You also don&#39;t want to call &quot;cur.close()&quot; if you have associated your cursor with the LoaderManager (as mentioned in my post). The system will close the cursor automatically for you.<br /><br />Let me know if I can clarify in any way, and thanks for bringing that up. :)<br /><br />Alex</div>
</div>
<div class='comment'>
<div class='author'>Dimath</div>
<div class='content'>
I am a little confused. I know I need to call <br /><br />SQLiteDatabase db = mOpenHelper.getReadableDatabase();<br /><br />inside the extended ContentProvider class, but don&#39;t I need to call <br /><br />db.close();<br /><br />at some point? Moreover, if I get a cursor <br /><br />Cursor mCursor = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);<br /><br />don&#39;t I also need to close it later? What would take care of closing the database and the cursors? Thanks!</div>
</div>
</div>
