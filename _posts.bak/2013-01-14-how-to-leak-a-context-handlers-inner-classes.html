---
layout: post
title: How to Leak a Context: Handlers & Inner Classes
date: 2013-01-14
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<p>Consider the following code:</p> <p><pre class="brush:java"><br />public class SampleActivity extends Activity {<br /><br />  private final Handler mLeakyHandler = new Handler() {<br />    @Override<br />    public void handleMessage(Message msg) {<br />      // ... <br />    }<br />  }<br />}<br /></pre></p> <p>While not readily obvious, this code can cause cause a massive memory leak. Android Lint will give the following warning: <i>"In Android, Handler classes should be static or leaks might occur."</i> But where exactly is the leak and how might it happen? Let's determine the source of the problem by first documenting what we know:</p> <ol> <li value="1"><p>When an Android application first starts, the framework creates a <code><a href="http://developer.android.com/reference/android/os/Looper.html">Looper</a></code> object for the application's main thread. A <code>Looper</code> implements a simple message queue, processing <code><a href="http://developer.android.com/reference/android/os/Message.html">Message</a></code> objects in a loop one after another. All major application framework events (such as Activity lifecycle method calls, button clicks, etc.) are contained inside <code>Message</code> objects, which are added to the <code>Looper</code>'s message queue and are processed one-by-one. The main thread's <code>Looper</code> exists throughout the application's lifecycle.</p></li> <li value="2"><p>When a <code><a href="http://developer.android.com/reference/android/os/Handler.html">Handler</a></code> is instantiated on the main thread, it is associated with the <code>Looper</code>'s message queue. Messages posted to the message queue will hold a reference to the <code>Handler</code> so that the framework can call <code><a href="http://developer.android.com/reference/android/os/Handler.html#handleMessage(android.os.Message)">Handler#handleMessage(Message)</a></code> when the <code>Looper</code> eventually processes the message.</p></li> <li value="3"><p>In Java, non-static inner and anonymous classes hold an implicit reference to their outer class. Static inner classes, on the other hand, do not.</p></li></ol> <a name='more'></a> <p>So where exactly is the memory leak? It's very subtle, but consider the following code as an example:</p> <p><pre class="brush:java"><br />public class SampleActivity extends Activity {<br /><br />  private final Handler mLeakyHandler = new Handler() {<br />    @Override<br />    public void handleMessage(Message msg) {<br />      // ...<br />    }<br />  }<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br /><br />    // Post a message and delay its execution for 10 minutes.<br />    mLeakyHandler.postDelayed(new Runnable() {<br />      @Override <br />      public void run() { }<br />    }, 60 * 10 * 1000);<br />    <br />    // Go back to the previous Activity.<br />    finish();<br />  }<br />}<br /></pre></p> <p>When the activity is finished, the delayed message will continue to live in the main thread's message queue for 10 minutes before it is processed. The message holds a reference to the activity's <code>Handler</code>, and the <code>Handler</code> holds an implicit reference to its outer class (the <code>SampleActivity</code>, in this case). This reference will persist until the message is processed, thus preventing the activity context from being garbage collected and leaking all of the application's resources. Note that the same is true with the anonymous Runnable class on line 15. Non-static instances of anonymous classes hold an implicit reference to their outer class, so the context will be leaked.</p> <p>To fix the problem, subclass the <code>Handler</code> in a new file or use a static inner class instead. Static inner classes do not hold an implicit reference to their outer class, so the activity will not be leaked. If you need to invoke the outer activity's methods from within the <code>Handler</code>, have the Handler hold a <code>WeakReference</code> to the activity so you don't accidentally leak a context. To fix the memory leak that occurs when we instantiate the anonymous Runnable class, we make the variable a static field of the class (since static instances of anonymous classes do not hold an implicit reference to their outer class):</p> <p><pre class="brush:java"><br />public class SampleActivity extends Activity {<br /><br />  /**<br />   * Instances of static inner classes do not hold an implicit<br />   * reference to their outer class.<br />   */<br />  private static class MyHandler extends Handler {<br />    private final WeakReference&lt;SampleActivity&gt; mActivity;<br /><br />    public MyHandler(SampleActivity activity) {<br />      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);<br />    }<br /><br />    @Override<br />    public void handleMessage(Message msg) {<br />      SampleActivity activity = mActivity.get();<br />      if (activity != null) {<br />        // ...<br />      }<br />    }<br />  }<br /><br />  private final MyHandler mHandler = new MyHandler(this);<br /><br />  /**<br />   * Instances of anonymous classes do not hold an implicit<br />   * reference to their outer class when they are "static".<br />   */<br />  private static final Runnable sRunnable = new Runnable() {<br />      @Override<br />      public void run() { }<br />  };<br /><br />  @Override<br />  protected void onCreate(Bundle savedInstanceState) {<br />    super.onCreate(savedInstanceState);<br /><br />    // Post a message and delay its execution for 10 minutes.<br />    mHandler.postDelayed(sRunnable, 600000);<br />    <br />    // Go back to the previous Activity.<br />    finish();<br />  }<br />}<br /></pre></p> <p>The difference between static and non-static inner classes is subtle, but is something every Android developer should understand. What's the bottom line? Avoid using non-static inner classes in an activity if instances of the inner class outlive the activity's lifecycle. Instead, prefer static inner classes and hold a weak reference to the activity inside.<p> <p>As always, leave a comment if you have any questions and don't forget to +1 this blog in the top right corner! :)</p></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
No problem. Hopefully I will have time to write a couple more during winter break. :)</div>
</div>
<div class='comment'>
<div class='author'>Rahul Sapra</div>
<div class='content'>
Hi Alex,<br /><br />Dude again great article. Many thanks for your help and best of luck for many more.</div>
</div>
<div class='comment'>
<div class='author'>Antonio Y</div>
<div class='content'>
Sorry, I think this code is exactly the one will make memory leak.<br />Thank you for your post. :) Learned a lot.</div>
</div>
<div class='comment'>
<div class='author'>Antonio Y</div>
<div class='content'>
Does it make memory leak for the following code?<br />(new Handler()).postDelayed(new Runnable() {<br />       @Override<br /> public void run() {<br /> // Do something.<br />        }<br />}, 1000);</div>
</div>
<div class='comment'>
<div class='author'>Vishnu Ravi</div>
<div class='content'>
Got here late! Still thanks for the information :)</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I mean messages that are posted to the event queue using the <i>Handler#postDelayed()</i> method.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
What do you mean by delayed messages?</div>
</div>
<div class='comment'>
<div class='author'>Tibib tu</div>
<div class='content'>
Good work.It help me so much!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
No, sorry. You could easily replicate it yourself though!</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
It&#39;s not really important what the kernel decides to do. The point of the article is this: if you post a delayed message using a non-static handler instance, your app is suddenly vulnerable to memory leaks.<br /><br />Sure you could argue that there are cases that the process/looper exits and the memory leak won&#39;t be a problem... but that&#39;s not the point of the article. The point is that it is possible for a memory leak to happen if you don&#39;t make the handler static, and therefore you should fix it. :)</div>
</div>
<div class='comment'>
<div class='author'>Ewoks</div>
<div class='content'>
is there full code of this handler leak example on git?</div>
</div>
<div class='comment'>
<div class='author'>ewoks</div>
<div class='content'>
&quot;If the app quits, then more likely the entire process will be killed by the kernel.&quot;<br /><br />more likely, eventually, meaning when kernel decides he should kill process to release some more resources.. But it may not happen for days.. or I am wrong? </div>
</div>
<div class='comment'>
<div class='author'>J</div>
<div class='content'>
Alex, great tutorial. I was wondering if you just had a activity nothing else. And if you check the MAT tool in eclipse you would notice. That on pressing back and coming out of the main activity, it still holds one reference which is held by mContext. Is there a way to avoid that?<br /><br />I have posted on SO about the same<br />http://stackoverflow.com/questions/17740751/android-memory-analyser-launcher-activity-object-retained-after-oncreate<br /><br />Any ideas of how to destroy that? Or is it a desired behaviour to have atleast one reference of your launcher by any chance?</div>
</div>
<div class='comment'>
<div class='author'>Maxim Dmitriev</div>
<div class='content'>
@PhilippeBanwarth, thank you. I understood you. The activity can&#39;t be garbage collected because it is used immediately after checking.<br /><br />SampleActivity activity = mActivity.get();<br />// Nothing is between these lines.<br />if (activity != null) {<br />    // ...<br />}</div>
</div>
<div class='comment'>
<div class='author'>Philippe Banwarth</div>
<div class='content'>
The code has been updated so there is no problem anymore.<br />If I remember correctly it used 2 times mActivity.get(), the first one to check if the reference was still there (not null), the second one to use it. This is a &quot;Time of check to time of use&quot; race condition : if you are (very) unlucky the garbage collector can remove the referenced object between the first and the second get().<br />The updated code use a temporary variable, wich is a normal (strong) reference. If it is not null it prevent the object from being collected<br /></div>
</div>
<div class='comment'>
<div class='author'>Maxim Dmitriev</div>
<div class='content'>
@Philippe Banwarth, could you give an example of the race you meant?</div>
</div>
<div class='comment'>
<div class='author'>gkg</div>
<div class='content'>
one more advantage of using Alex&#39;s way could be that we can have more structured code.<br />Now, we can easily maintain handlers in different class files, which will be explicitly visible in src code folder.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
If the app quits, then more likely the entire process will be killed by the kernel. The example I gave is pretty simple and what you are saying is definitely correct... I guess this post was more about explaining the concept and assumed that the Looper wouldn&#39;t suddenly quit after the Activity was finished. :)</div>
</div>
<div class='comment'>
<div class='author'>Herve</div>
<div class='content'>
Copy-pasted from SDK doc. The message will be dropped is the looper is quit. Doesn&#39;t that mean if the app quits, the message will be dropped, thus no reference being held?<br /><br />Returns true if the Runnable was successfully placed in to the message queue. Returns false on failure, usually because the looper processing the message queue is exiting. Note that a result of true does not mean the Runnable will be processed -- if the looper is quit before the delivery time of the message occurs then the message will be dropped.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
I agree that this area of Android development can be somewhat confusing (it&#39;s way too easy to leak context objects in Android... and the concept of a Context in general could have been made a little clearer too, I think). But I wouldn&#39;t go as far to say that it&#39;s difficult to do &quot;anything&quot; correctly.</div>
</div>
<div class='comment'>
<div class='author'>Kevin</div>
<div class='content'>
This post and its comments have reinforced my feeling that Android&#39;s greatest weakness is that it&#39;s so frakkin&#39; hard for developers to do anything correctly! :-/</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
It&#39;s totally fine to use WeakReference in Android. It&#39;s useful in scenarios when you want to hold a reference to an Object for as long as it persists on the heap (ie, until it is eventually garbage collected).</div>
</div>
<div class='comment'>
<div class='author'>abeeeeee</div>
<div class='content'>
I actually prefer to have a service do all the processing; the service owns a handler and all the necessary threads and long-lasting states. Any data that is intended to be shown is then broadcast back to the activities.<br /><br />This keeps the Activity code very light.<br /><br />It also means that I only need to worry about configuring proguard to obfuscate the service.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Because without the WeakReference, it&#39;s a strong reference. :)</div>
</div>
<div class='comment'>
<div class='author'>Satish B</div>
<div class='content'>
&quot;so you need to make sure the Handler doesn&#39;t hold a strong reference to the Activity/Context. &quot; - This is the reason we&#39;ve made Handler a static inner class. So, why again we have to pass WeakReference of the activity.</div>
</div>
<div class='comment'>
<div class='author'>s-a--m</div>
<div class='content'>
On http://developer.android.com/intl/ru/reference/java/lang/ref/WeakReference.html<br />I read that WeakReference may be cleared as soon as is known to be weakly-referenced. I thought that such use of WeakReference is not recommended but I dont know it for sure.<br /><br />Thank you for this article.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
What happens if you do what? Not sure which part you are referring to.</div>
</div>
<div class='comment'>
<div class='author'>s-a--m</div>
<div class='content'>
What happens if I do this on Android? Could I use WeakReference to Activity context? Or dalvic will eat this?</div>
</div>
<div class='comment'>
<div class='author'>helal khan</div>
<div class='content'>
Great post.It helps me so much . Thanks a lot</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yeah... my head is starting to hurt too. :P<br /><br />I guess we could make the Runnable a static inner class, if it was really necessary to do so. There are obviously a lot of ways you can mess up here... so it might in fact be a better idea to just remove the Runnable from the queue in onDestroy(), just to be safe.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Yup, pretty much.</div>
</div>
<div class='comment'>
<div class='author'>andy-dennie</div>
<div class='content'>
ugh, my brain is starting to hurt... just realized that the mRunnable field suggested by Cyril is itself a reference to the runnable, so for everything to get GC&#39;d correctly, you&#39;d have to set mRunnable to null after removing it from the handler in onDestroy.  I think.</div>
</div>
<div class='comment'>
<div class='author'>andy-dennie</div>
<div class='content'>
Thinking about this some more, you probably don&#39;t want to make that Runnable a static member, because then it won&#39;t be able to access the Activity instance from its run() method. <br /><br />However, I&#39;m thinking that if you remove the Runnable from the handler in onDestroy, as Cyril suggested above, then when the Activity finishes, the Runnable will no longer have any external references to itself, so it can be GC&#39;d, which will remove its implicit reference to the outer Activity class, thus allowing IT to be GC&#39;d.</div>
</div>
<div class='comment'>
<div class='author'>Fifarunnerr</div>
<div class='content'>
So basically, as long as your handler doesn&#39;t use postDelayed for more than a few seconds and the handleMessage method does only take a seconds, the memory leak ain&#39;t a problem?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Wow, you&#39;re right... great catch. This stuff never ends, does it. :P<br /><br />I updated the post by making the runnable &quot;static&quot;, which works too (since static instances of anonymous classes don&#39;t hold an implicit reference to their outer class). Thanks!</div>
</div>
<div class='comment'>
<div class='author'>andy-dennie</div>
<div class='content'>
Hmm, wouldn&#39;t the anonymous Runnable at line 15 of the second code listing create the same problem as the anonymous Handler?  Should it be a static inner class also?</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Good call, Cyril. Thanks for the suggestion! In most cases, removing Activity-specific messages from the message queue is probably a good idea.</div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
You&#39;re right. This is what I originally had actually, but I was lazy and chose brevity over correctness without realizing. I&#39;ll update the post. :)</div>
</div>
<div class='comment'>
<div class='author'>Marc Reichelt</div>
<div class='content'>
I created a class that fixes the problem, which I called &#39;WeakHandler&#39;.<br />I uploaded the code here: http://pastebin.com/vCLY57Ug<br /><br />It also fixes the race condition which Phillippe Banwarth mentioned while still resolving possible memory leaks.<br />Cyril is correct, too - all delayed messages sent to the handler should be removed in onDestroy(), or even better in onPause().</div>
</div>
<div class='comment'>
<div class='author'>Cyril</div>
<div class='content'>
@Philippe Banwarth: Yep it is.<br /><br />@Alex Lockwood: You can also simply mHandler.remove(mRunnable) in onDestroy().</div>
</div>
<div class='comment'>
<div class='author'>Philippe Banwarth</div>
<div class='content'>
Isn&#39;t<br /><br />    public void handleMessage(Message msg) {<br />        SampleActivity activity = mActivity.get();<br />        if (activity != null) {<br />            /* do something with activity */<br />        }<br />    }<br /><br />even better, as it avoid a race condition (The activity disappearing between the check and the actual use)<br />(sorry about the formatting)<br /></div>
</div>
<div class='comment'>
<div class='author'>Alex Lockwood</div>
<div class='content'>
Because the message in the queue holds a reference to the Handler, so you need to make sure the Handler doesn&#39;t hold a strong reference to the Activity/Context. :)<br /><br />I got a comment earlier asking about how this works with AsyncTasks... I think I&#39;ll look into that more as a subject for my next blog post!</div>
</div>
<div class='comment'>
<div class='author'>Kiran Rao</div>
<div class='content'>
Great post! I have read about this potential memory leak several times but never really understood the finer details until now.<br /><br />Does the same reasoning hold for AsyncTasks too? Also, what&#39;s with the WeakReference? why not just pass in the Activity or Context itself down to the constructor of the static inner class?<br /><br />I think I&#39;ve already provided you fodder for your next post :-)</div>
</div>
</div>
