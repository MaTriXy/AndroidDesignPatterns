---
layout: post
title: Reaping the Benefits of the LoaderManager
date: 2012-05-26
permalink: /2012/05/why-you-should-use-loadermanager.html
comments: true
---

<p><b>Note: <a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html">Check out my new posts on Loaders here!</a> (Since writing this post, I've written extensively on Loaders and the LoaderManager).</b></p>

<p>With Android 3.0 came the introduction of the <code>LoaderManager</code> class, an abstract class associated with an <code>Activity</code> or <code>Fragment</code> for managing one or more <code>Loader</code> instances. The <code>LoaderManager</code> class is one of my favorite additions to the Android framework for a number of reasons, but mostly because it <i>significantly</i> reduces code complexity and makes your application run a lot smoother. Implementing data loaders with the <code>LoaderManager</code> is simple to implement, and takes care of everything about lifecycle management so are much less error prone.</p>

<p>While applications are free to write their own loaders for loading various types of data, the most common (and simplest) use of the <code>LoaderManager</code> is with a <code>CursorLoader</code>. When done correctly, the <code>CursorLoader</code> class offloads the work of loading data on a thread, and keeps the data persistent during short term activity refresh events, such as an orientation change. In addition to performing the initial query, the <code>CursorLoader</code> registers a <code>ContentObserver</code> with the dataset you requested and calls <code>forceLoad()</code> on itself when the data set changes, and is thus auto-updating. This is extremely convenient for the programmer, as he doesn't have to worry about performing these queries himself. Further, for bigger screens it becomes more important that you query on a separate thread since configuration changes involve recreating the entire view layout, a complex operation that can cause disasters when blocked.</p>

<!--more-->

<p>As mentioned earlier, one could implement his or her class to load data on a separate thread using an <code>AsyncTask</code> or even a <code>Thread</code> (God help us). The point, however, is that the <code>LoaderManager</code> does this all for you, so it's convenient for the developer, less error prone, and simple to implement. Of course it is possible to use an <code>AsyncTask</code> to keep your application UI thread friendly, but it will involve a lot more code, and implementing your class so that it will retain the loaded <code>Cursor</code> over the twists and turns of the <code>Activity</code> lifecycle won't be simple. The bottom line is that <code>LoaderManager</code> will do this automatically for you, as well as taking care of correctly creating and closing the <code>Cursor</code> based on the <code>Activity</code> lifecycle.</p>

<p>To use <code>LoaderManager</code> with (or without) the <code>CursorLoader</code> in an app targeting pre-HoneyComb devices, you should make use of the classes provided in the Android Support Package, including the <code>FragmentActivity</code> class. A <code>FragmentActivity</code> is just an <code>Activity</code> that has been created for Android compatibility support, and does not require the use of fragments in your application. When transitioning from an <code>Activity</code>s to <code>FragmentActivity</code>s, be extremely careful that you use the <code>getSupportLoaderManager()</code> instead of <code>getLoaderManager()</code>. <code>FragmentActivity</code> extends <code>Activity</code>, thus inheriting all of its methods, and as a result the compiler will not complain if you accidentally mix up these methods, so be very careful!</p>

<p>Leave a comment if you have any questions or criticisms... or just to let me know that you managed to read through this entire post without getting distracted! I'm also open to providing more explicit code samples if anyone asks.</p>